From c9a2090d740fe8860b2ac37741a7abd25032f6f8 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Mon, 18 Dec 2023 12:51:39 +0200
Subject: [PATCH 1/1] Seal Security Hotfix for ncurses-libs 5.9-14.20130511.el7_4

This patch fixes:
  CVE-2023-29491

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://git.centos.org/rpms/ncurses/tree/71d85326c8206d2ba4d1a5a20e1221117d8c3617
---
 ncurses/tinfo/lib_tgoto.c  |  5 ++-
 ncurses/tinfo/lib_tparm.c  | 62 ++++++++++++++++++++++++++++++++++++++
 ncurses/tinfo/read_entry.c |  3 ++
 progs/tput.c               | 13 ++++++++
 4 files changed, 82 insertions(+), 1 deletion(-)

diff --git a/ncurses/tinfo/lib_tgoto.c b/ncurses/tinfo/lib_tgoto.c
index 31daf44..3d347bf 100644
--- a/ncurses/tinfo/lib_tgoto.c
+++ b/ncurses/tinfo/lib_tgoto.c
@@ -199,6 +199,9 @@ tgoto(const char *string, int x, int y)
 	result = tgoto_internal(string, x, y);
     else
 #endif
-	result = TPARM_2((NCURSES_CONST char *) string, y, x);
+	if ((result = TPARM_2((NCURSES_CONST char *) string, y, x)) == NULL) {
+	    result = TPARM_1((NCURSES_CONST char *) string, y);
+	}
+
     returnPtr(result);
 }
diff --git a/ncurses/tinfo/lib_tparm.c b/ncurses/tinfo/lib_tparm.c
index 18b6de0..c0f76fa 100644
--- a/ncurses/tinfo/lib_tparm.c
+++ b/ncurses/tinfo/lib_tparm.c
@@ -451,6 +451,63 @@ _nc_tparm_analyze(const char *string, char *p_is_s[NUM_PARM], int *popcount)
     return number;
 }
 
+#ifdef CUR
+/*
+ * Only a few standard capabilities accept string parameters.  The others that
+ * are parameterized accept only numeric parameters.
+ */
+static bool
+check_string_caps(const char *string, int tparm_type)
+{
+    bool result = FALSE;
+
+#define CHECK_CAP(name) (VALID_STRING(name) && !strcmp(name, string))
+
+    /*
+     * Disallow string parameters unless we can check them against a terminal
+     * description.
+     */
+    if (cur_term != NULL) {
+	int want_type = 0;
+
+	if (CHECK_CAP(pkey_key))
+	    want_type = 2;	/* function key #1, type string #2 */
+	else if (CHECK_CAP(pkey_local))
+	    want_type = 2;	/* function key #1, execute string #2 */
+	else if (CHECK_CAP(pkey_xmit))
+	    want_type = 2;	/* function key #1, transmit string #2 */
+	else if (CHECK_CAP(plab_norm))
+	    want_type = 2;	/* label #1, show string #2 */
+	else if (CHECK_CAP(pkey_plab))
+	    want_type = 6;	/* function key #1, type string #2, show string #3 */
+#if NCURSES_XNAMES
+	else {
+	    char *check;
+
+	    check = tigetstr("Cs");
+	    if (CHECK_CAP(check))
+		want_type = 1;	/* style #1 */
+
+	    check = tigetstr("Ms");
+	    if (CHECK_CAP(check))
+		want_type = 3;	/* storage unit #1, content #2 */
+	}
+#endif
+
+	if (want_type == tparm_type || tparm_type == 0) {
+	    result = TRUE;
+	} else {
+	    T(("unexpected string-parameter"));
+	}
+    }
+    return result;
+}
+
+#define ValidCap() (check_string_caps(string, tparm_type))
+#else
+#define ValidCap() 1
+#endif
+
 static NCURSES_INLINE char *
 tparam_internal(int use_TPARM_ARG, const char *string, va_list ap)
 {
@@ -459,6 +516,7 @@ tparam_internal(int use_TPARM_ARG, const char *string, va_list ap)
     int popcount = 0;
     int number;
     int num_args;
+    int tparm_type = 0;
     int len;
     int level;
     int x, y;
@@ -498,6 +556,7 @@ tparam_internal(int use_TPARM_ARG, const char *string, va_list ap)
 	if (p_is_s[i] != 0) {
 	    p_is_s[i] = va_arg(ap, char *);
 	    param[i] = 0;
+	    tparm_type |= (1 << i);
 	} else if (use_TPARM_ARG) {
 	    param[i] = va_arg(ap, TPARM_ARG);
 	} else {
@@ -505,6 +564,9 @@ tparam_internal(int use_TPARM_ARG, const char *string, va_list ap)
 	}
     }
 
+    if (!ValidCap()) {
+	    return NULL;
+    }
     /*
      * This is a termcap compatibility hack.  If there are no explicit pop
      * operations in the string, load the stack in such a way that
diff --git a/ncurses/tinfo/read_entry.c b/ncurses/tinfo/read_entry.c
index a74bfd7..2a15161 100644
--- a/ncurses/tinfo/read_entry.c
+++ b/ncurses/tinfo/read_entry.c
@@ -152,6 +152,9 @@ _nc_read_termtype(TERMTYPE *ptr, char *buffer, int limit)
 	|| bool_count < 0
 	|| num_count < 0
 	|| str_count < 0
+	|| bool_count > BOOLCOUNT
+	|| num_count > NUMCOUNT
+	|| str_count > STRCOUNT
 	|| str_size < 0) {
 	return (TGETENT_NO);
     }
diff --git a/progs/tput.c b/progs/tput.c
index d29ed0a..30ba79a 100644
--- a/progs/tput.c
+++ b/progs/tput.c
@@ -55,8 +55,10 @@ MODULE_ID("$Id: tput.c,v 1.48 2012/02/18 21:51:17 tom Exp $")
 
 typedef enum {
     Numbers = 0
+    ,Str
     ,Num_Str
     ,Num_Str_Str
+    ,Str_Str
 } TParams;
 
 static char *prg_name;
@@ -99,6 +101,7 @@ static TParams
 tparm_type(const char *name)
 {
 #define TD(code, longname, ti, tc) {code,longname},{code,ti},{code,tc}
+#define XD(code, onlyname) TD(code, onlyname, onlyname, onlyname)
     TParams result = Numbers;
     /* *INDENT-OFF* */
     static const struct {
@@ -110,6 +113,10 @@ tparm_type(const char *name)
 	TD(Num_Str,	"pkey_xmit",	"pfx",		"px"),
 	TD(Num_Str,	"plab_norm",	"pln",		"pn"),
 	TD(Num_Str_Str, "pkey_plab",	"pfxl",		"xl"),
+#if NCURSES_XNAMES
+	XD(Str,		"Cs"),
+	XD(Str_Str,	"Ms"),
+#endif
     };
     /* *INDENT-ON* */
 
@@ -326,6 +333,12 @@ tput(int argc, char *argv[])
 	    }
 
 	    switch (tparm_type(name)) {
+	    case Str:
+		s = TPARM_1(s, strings[1]);
+		break;
+	    case Str_Str:
+		s = TPARM_2(s, strings[1], strings[2]);
+		break;
 	    case Num_Str:
 		s = TPARM_2(s, numbers[1], strings[2]);
 		break;
-- 

