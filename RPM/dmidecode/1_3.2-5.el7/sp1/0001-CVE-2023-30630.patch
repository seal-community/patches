From 7eff6361e8fb038d4f6728eae201a74b334aff92 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Tue, 19 Dec 2023 17:58:52 +0200
Subject: [PATCH 1/1] Seal Security Hotfix for dmidecode 1:3.2-5.el7

This patch fixes:
  CVE-2023-30630

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://git.centos.org/rpms/dmidecode/tree/0fa4e7b83984878360f393522603cbb46f2e8953
---
 dmidecode.c | 150 +++++++++++++++++++++++++++++++++++++++-------------
 util.c      |  40 --------------
 util.h      |   1 -
 3 files changed, 112 insertions(+), 79 deletions(-)

diff --git a/dmidecode.c b/dmidecode.c
index a3e9d6c..0b0c40b 100644
--- a/dmidecode.c
+++ b/dmidecode.c
@@ -60,6 +60,7 @@
  *    https://www.dmtf.org/sites/default/files/DSP0270_1.0.1.pdf
  */
 
+#include <fcntl.h>
 #include <stdio.h>
 #include <string.h>
 #include <strings.h>
@@ -5094,11 +5095,65 @@ static void dmi_table_string(const struct dmi_header *h, const u8 *data, u16 ver
 	}
 }
 
-static void dmi_table_dump(const u8 *buf, u32 len)
+static int dmi_table_dump(const u8 *ep, u32 ep_len, const u8 *table,
+			  u32 table_len)
 {
+	int fd;
+	FILE *f;
+
+	fd = open(opt.dumpfile, O_WRONLY|O_CREAT|O_EXCL, 0666);
+	if (fd == -1)
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("open");
+		return -1;
+	}
+
+	f = fdopen(fd, "wb");
+	if (!f)
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("fdopen");
+		return -1;
+	}
+
+	if (!(opt.flags & FLAG_QUIET))
+		printf("Writing %d bytes to %s.\n", ep_len, opt.dumpfile);
+	if (fwrite(ep, ep_len, 1, f) != 1)
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("fwrite");
+		goto err_close;
+	}
+
+	if (fseek(f, 32, SEEK_SET) != 0)
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("fseek");
+		goto err_close;
+	}
+
 	if (!(opt.flags & FLAG_QUIET))
-		printf("# Writing %d bytes to %s.\n", len, opt.dumpfile);
-	write_dump(32, len, buf, opt.dumpfile, 0);
+		printf("Writing %d bytes to %s.\n", table_len, opt.dumpfile);
+	if (fwrite(table, table_len, 1, f) != 1)
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("fwrite");
+		goto err_close;
+	}
+
+	if (fclose(f))
+	{
+		fprintf(stderr, "%s: ", opt.dumpfile);
+		perror("fclose");
+		return -1;
+	}
+
+	return 0;
+
+err_close:
+	fclose(f);
+	return -1;
 }
 
 static void dmi_table_decode(u8 *buf, u32 len, u16 num, u16 ver, u32 flags)
@@ -5211,7 +5266,7 @@ static void dmi_table_decode(u8 *buf, u32 len, u16 num, u16 ver, u32 flags)
 	}
 }
 
-static void dmi_table(off_t base, u32 len, u16 num, u32 ver, const char *devmem,
+static u8 *dmi_table(off_t base, u32 *len, u16 num, u32 ver, const char *devmem,
 		      u32 flags)
 {
 	u8 *buf;
@@ -5231,7 +5286,7 @@ static void dmi_table(off_t base, u32 len, u16 num, u32 ver, const char *devmem,
 		{
 			if (num)
 				printf("%u structures occupying %u bytes.\n",
-				       num, len);
+				       num, *len);
 			if (!(opt.flags & FLAG_FROM_DUMP))
 				printf("Table at 0x%08llX.\n",
 				       (unsigned long long)base);
@@ -5249,19 +5304,19 @@ static void dmi_table(off_t base, u32 len, u16 num, u32 ver, const char *devmem,
 		 * would be the result of the kernel truncating the table on
 		 * parse error.
 		 */
-		size_t size = len;
+		size_t size = *len;
 		buf = read_file(flags & FLAG_NO_FILE_OFFSET ? 0 : base,
 			&size, devmem);
-		if (!(opt.flags & FLAG_QUIET) && num && size != (size_t)len)
+		if (!(opt.flags & FLAG_QUIET) && num && size != (size_t)*len)
 		{
 			fprintf(stderr, "Wrong DMI structures length: %u bytes "
 				"announced, only %lu bytes available.\n",
-				len, (unsigned long)size);
+				*len, (unsigned long)size);
 		}
-		len = size;
+		*len = size;
 	}
 	else
-		buf = mem_chunk(base, len, devmem);
+		buf = mem_chunk(base, *len, devmem);
 
 	if (buf == NULL)
 	{
@@ -5271,15 +5326,9 @@ static void dmi_table(off_t base, u32 len, u16 num, u32 ver, const char *devmem,
 			fprintf(stderr,
 				"Try compiling dmidecode with -DUSE_MMAP.\n");
 #endif
-		return;
+		return NULL;
 	}
-
-	if (opt.flags & FLAG_DUMP_BIN)
-		dmi_table_dump(buf, len);
-	else
-		dmi_table_decode(buf, len, num, ver >> 8, flags);
-
-	free(buf);
+	return buf;
 }
 
 
@@ -5314,8 +5363,9 @@ static void overwrite_smbios3_address(u8 *buf)
 
 static int smbios3_decode(u8 *buf, const char *devmem, u32 flags)
 {
-	u32 ver;
+	u32 ver, len;
 	u64 offset;
+	u8 *table;
 
 	/* Don't let checksum run beyond the buffer */
 	if (buf[0x06] > 0x20)
@@ -5341,8 +5391,12 @@ static int smbios3_decode(u8 *buf, const char *devmem, u32 flags)
 		return 0;
 	}
 
-	dmi_table(((off_t)offset.h << 32) | offset.l,
-		  DWORD(buf + 0x0C), 0, ver, devmem, flags | FLAG_STOP_AT_EOT);
+	len = DWORD(buf + 0x0C);
+	table = dmi_table(((off_t)offset.h << 32) | offset.l,
+		  &len, 0, ver, devmem, flags | FLAG_STOP_AT_EOT);
+	
+	if (table == NULL)
+		return 1;
 
 	if (opt.flags & FLAG_DUMP_BIN)
 	{
@@ -5351,18 +5405,23 @@ static int smbios3_decode(u8 *buf, const char *devmem, u32 flags)
 		memcpy(crafted, buf, 32);
 		overwrite_smbios3_address(crafted);
 
-		if (!(opt.flags & FLAG_QUIET))
-			printf("# Writing %d bytes to %s.\n", crafted[0x06],
-			       opt.dumpfile);
-		write_dump(0, crafted[0x06], crafted, opt.dumpfile, 1);
+		dmi_table_dump(crafted, crafted[0x06], table, len);
 	}
+	else 
+	{
+		dmi_table_decode(buf, len, 0, ver >> 8, flags | FLAG_STOP_AT_EOT);
+	}
+
+	free(table);
 
 	return 1;
 }
 
 static int smbios_decode(u8 *buf, const char *devmem, u32 flags)
 {
-	u16 ver;
+	u16 ver, num;
+	u32 len;
+	u8 *table;
 
 	/* Don't let checksum run beyond the buffer */
 	if (buf[0x05] > 0x20)
@@ -5402,9 +5461,14 @@ static int smbios_decode(u8 *buf, const char *devmem, u32 flags)
 		printf("SMBIOS %u.%u present.\n",
 			ver >> 8, ver & 0xFF);
 
-	dmi_table(DWORD(buf + 0x18), WORD(buf + 0x16), WORD(buf + 0x1C),
+	len = WORD(buf + 0x16);
+	num = WORD(buf + 0x1C);
+	table = dmi_table(DWORD(buf + 0x18), &len, num,
 		ver << 8, devmem, flags);
 
+	if (table == NULL)
+		return 1;
+
 	if (opt.flags & FLAG_DUMP_BIN)
 	{
 		u8 crafted[32];
@@ -5412,27 +5476,35 @@ static int smbios_decode(u8 *buf, const char *devmem, u32 flags)
 		memcpy(crafted, buf, 32);
 		overwrite_dmi_address(crafted + 0x10);
 
-		if (!(opt.flags & FLAG_QUIET))
-			printf("# Writing %d bytes to %s.\n", crafted[0x05],
-				opt.dumpfile);
-		write_dump(0, crafted[0x05], crafted, opt.dumpfile, 1);
+		dmi_table_dump(crafted, crafted[0x05], table, len);
+	}
+	else
+	{
+		dmi_table_decode(buf, len, num, ver >> 8, flags);
 	}
+	free(table);
 
 	return 1;
 }
 
 static int legacy_decode(u8 *buf, const char *devmem, u32 flags)
 {
+	u16 ver, num;
+	u32 len;
+	u8 *table;
+
 	if (!checksum(buf, 0x0F))
 		return 0;
 
+	ver = ((buf[0x0E] & 0xF0) << 12) + ((buf[0x0E] & 0x0F) << 8);
 	if (!(opt.flags & FLAG_QUIET))
 		printf("Legacy DMI %u.%u present.\n",
 			buf[0x0E] >> 4, buf[0x0E] & 0x0F);
 
-	dmi_table(DWORD(buf + 0x08), WORD(buf + 0x06), WORD(buf + 0x0C),
-		((buf[0x0E] & 0xF0) << 12) + ((buf[0x0E] & 0x0F) << 8),
-		devmem, flags);
+	len = WORD(buf + 0x06);
+	num = WORD(buf + 0x0C);
+	table = dmi_table(DWORD(buf + 0x08), &len, num,
+		ver, devmem, flags);
 
 	if (opt.flags & FLAG_DUMP_BIN)
 	{
@@ -5441,11 +5513,13 @@ static int legacy_decode(u8 *buf, const char *devmem, u32 flags)
 		memcpy(crafted, buf, 16);
 		overwrite_dmi_address(crafted);
 
-		if (!(opt.flags & FLAG_QUIET))
-			printf("# Writing %d bytes to %s.\n", 0x0F,
-				opt.dumpfile);
-		write_dump(0, 0x0F, crafted, opt.dumpfile, 1);
+		dmi_table_dump(crafted, 0x0F, table, len);
+	}
+	else
+	{
+		dmi_table_decode(buf, len, num, ver, flags);
 	}
+	free(table);
 
 	return 1;
 }
diff --git a/util.c b/util.c
index eeffdae..2e1931c 100644
--- a/util.c
+++ b/util.c
@@ -247,46 +247,6 @@ out:
 	return p;
 }
 
-int write_dump(size_t base, size_t len, const void *data, const char *dumpfile, int add)
-{
-	FILE *f;
-
-	f = fopen(dumpfile, add ? "r+b" : "wb");
-	if (!f)
-	{
-		fprintf(stderr, "%s: ", dumpfile);
-		perror("fopen");
-		return -1;
-	}
-
-	if (fseek(f, base, SEEK_SET) != 0)
-	{
-		fprintf(stderr, "%s: ", dumpfile);
-		perror("fseek");
-		goto err_close;
-	}
-
-	if (fwrite(data, len, 1, f) != 1)
-	{
-		fprintf(stderr, "%s: ", dumpfile);
-		perror("fwrite");
-		goto err_close;
-	}
-
-	if (fclose(f))
-	{
-		fprintf(stderr, "%s: ", dumpfile);
-		perror("fclose");
-		return -1;
-	}
-
-	return 0;
-
-err_close:
-	fclose(f);
-	return -1;
-}
-
 /* Returns end - start + 1, assuming start < end */
 u64 u64_range(u64 start, u64 end)
 {
diff --git a/util.h b/util.h
index 3094cf8..ef24eb9 100644
--- a/util.h
+++ b/util.h
@@ -27,5 +27,4 @@
 int checksum(const u8 *buf, size_t len);
 void *read_file(off_t base, size_t *len, const char *filename);
 void *mem_chunk(off_t base, size_t len, const char *devmem);
-int write_dump(size_t base, size_t len, const void *data, const char *dumpfile, int add);
 u64 u64_range(u64 start, u64 end);
-- 

