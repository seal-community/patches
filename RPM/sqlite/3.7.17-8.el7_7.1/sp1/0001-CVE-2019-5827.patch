From f3865eba7d28f5c738607b1c6027d827a8f675c3 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Wed, 20 Dec 2023 18:46:31 +0200
Subject: [PATCH 1/1] Seal Security Hotfix for sqlite 3.7.17-8.el7_7.1

This patch fixes:
  CVE-2019-5827

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://git.centos.org/rpms/sqlite/tree/f1f4b9c5680735437fb2bb9c94eab503550d9d8b
---
 ext/fts3/fts3_snippet.c   |  6 +++---
 ext/fts3/fts3_test.c      |  4 ++--
 ext/fts3/fts3_tokenizer.c |  2 +-
 ext/fts3/fts3_write.c     | 12 ++++++------
 ext/rtree/rtree.c         |  8 ++++----
 src/build.c               |  6 +++---
 src/expr.c                |  2 +-
 src/main.c                |  2 +-
 src/test_fs.c             |  2 +-
 src/vdbeaux.c             |  2 +-
 src/vdbesort.c            |  2 +-
 src/vtab.c                | 18 +++++++++++-------
 12 files changed, 35 insertions(+), 31 deletions(-)

diff --git a/ext/fts3/fts3_snippet.c b/ext/fts3/fts3_snippet.c
index d54a787..45839af 100644
--- a/ext/fts3/fts3_snippet.c
+++ b/ext/fts3/fts3_snippet.c
@@ -1151,8 +1151,8 @@ static int fts3GetMatchinfo(
   ** initialize those elements that are constant for every row.
   */
   if( pCsr->aMatchinfo==0 ){
-    int nMatchinfo = 0;           /* Number of u32 elements in match-info */
-    int nArg;                     /* Bytes in zArg */
+    sqlite3_int64 nMatchinfo = 0;           /* Number of u32 elements in match-info */
+    sqlite3_int64 nArg;                     /* Bytes in zArg */
     int i;                        /* Used to iterate through zArg */
 
     /* Determine the number of phrases in the query */
@@ -1165,7 +1165,7 @@ static int fts3GetMatchinfo(
     }
 
     /* Allocate space for Fts3Cursor.aMatchinfo[] and Fts3Cursor.zMatchinfo. */
-    nArg = (int)strlen(zArg);
+    nArg = strlen(zArg);
     pCsr->aMatchinfo = (u32 *)sqlite3_malloc(sizeof(u32)*nMatchinfo + nArg + 1);
     if( !pCsr->aMatchinfo ) return SQLITE_NOMEM;
 
diff --git a/ext/fts3/fts3_test.c b/ext/fts3/fts3_test.c
index 75ec6bd..a4e1bc4 100644
--- a/ext/fts3/fts3_test.c
+++ b/ext/fts3/fts3_test.c
@@ -441,9 +441,9 @@ static int testTokenizerNext(
   }else{
     /* Advance to the end of the token */
     const char *pToken = p;
-    int nToken;
+    sqlite3_int64 nToken;
     while( p<pEnd && testIsTokenChar(*p) ) p++;
-    nToken = (int)(p-pToken);
+    nToken = (sqlite3_int64)(p-pToken);
 
     /* Copy the token into the buffer */
     if( nToken>pCsr->nBuffer ){
diff --git a/ext/fts3/fts3_tokenizer.c b/ext/fts3/fts3_tokenizer.c
index 04f8446..87f9029 100644
--- a/ext/fts3/fts3_tokenizer.c
+++ b/ext/fts3/fts3_tokenizer.c
@@ -173,7 +173,7 @@ int sqlite3Fts3InitTokenizer(
     int iArg = 0;
     z = &z[n+1];
     while( z<zEnd && (NULL!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){
-      int nNew = sizeof(char *)*(iArg+1);
+      sqlite3_int64 nNew = sizeof(char *)*(iArg+1);
       char const **aNew = (const char **)sqlite3_realloc((void *)aArg, nNew);
       if( !aNew ){
         sqlite3_free(zCopy);
diff --git a/ext/fts3/fts3_write.c b/ext/fts3/fts3_write.c
index 269d1dd..b7efaf3 100644
--- a/ext/fts3/fts3_write.c
+++ b/ext/fts3/fts3_write.c
@@ -1708,7 +1708,7 @@ int sqlite3Fts3SegReaderPending(
   }
 
   if( nElem>0 ){
-    int nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
+    sqlite3_int64 nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
     pReader = (Fts3SegReader *)sqlite3_malloc(nByte);
     if( !pReader ){
       rc = SQLITE_NOMEM;
@@ -3117,7 +3117,7 @@ static void fts3InsertDocsize(
   int rc;                  /* Result code from subfunctions */
 
   if( *pRC ) return;
-  pBlob = sqlite3_malloc( 10*p->nColumn );
+  pBlob = sqlite3_malloc( 10*(sqlite3_int64)p->nColumn );
   if( pBlob==0 ){
     *pRC = SQLITE_NOMEM;
     return;
@@ -3167,7 +3167,7 @@ static void fts3UpdateDocTotals(
   const int nStat = p->nColumn+2;
 
   if( *pRC ) return;
-  a = sqlite3_malloc( (sizeof(u32)+10)*nStat );
+  a = sqlite3_malloc( (sizeof(u32)+10)*(sqlite3_int64)nStat );
   if( a==0 ){
     *pRC = SQLITE_NOMEM;
     return;
@@ -3286,7 +3286,7 @@ static int fts3DoRebuild(Fts3Table *p){
     }
 
     if( rc==SQLITE_OK ){
-      int nByte = sizeof(u32) * (p->nColumn+1)*3;
+      sqlite3_int64 nByte = sizeof(u32) * ((sqlite3_int64)p->nColumn+1)*3;
       aSz = (u32 *)sqlite3_malloc(nByte);
       if( aSz==0 ){
         rc = SQLITE_NOMEM;
@@ -3351,7 +3351,7 @@ static int fts3IncrmergeCsr(
 ){
   int rc;                         /* Return Code */
   sqlite3_stmt *pStmt = 0;        /* Statement used to read %_segdir entry */  
-  int nByte;                      /* Bytes allocated at pCsr->apSegment[] */
+  sqlite3_int64 nByte;                      /* Bytes allocated at pCsr->apSegment[] */
 
   /* Allocate space for the Fts3MultiSegReader.aCsr[] array */
   memset(pCsr, 0, sizeof(*pCsr));
@@ -5289,7 +5289,7 @@ int sqlite3Fts3UpdateMethod(
   }
 
   /* Allocate space to hold the change in document sizes */
-  aSzDel = sqlite3_malloc( sizeof(aSzDel[0])*(p->nColumn+1)*2 );
+  aSzDel = sqlite3_malloc( sizeof(aSzDel[0])*((sqlite3_int64)p->nColumn+1)*2 );
   if( aSzDel==0 ){
     rc = SQLITE_NOMEM;
     goto update_out;
diff --git a/ext/rtree/rtree.c b/ext/rtree/rtree.c
index 16a316f..7539986 100644
--- a/ext/rtree/rtree.c
+++ b/ext/rtree/rtree.c
@@ -3100,8 +3100,8 @@ static int rtreeInit(
 ){
   int rc = SQLITE_OK;
   Rtree *pRtree;
-  int nDb;              /* Length of string argv[1] */
-  int nName;            /* Length of string argv[2] */
+  sqlite3_int64 nDb;              /* Length of string argv[1] */
+  sqlite3_int64 nName;            /* Length of string argv[2] */
   int eCoordType = (pAux ? RTREE_COORD_INT32 : RTREE_COORD_REAL32);
 
   const char *aErrMsg[] = {
@@ -3120,8 +3120,8 @@ static int rtreeInit(
   sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);
 
   /* Allocate the sqlite3_vtab structure */
-  nDb = (int)strlen(argv[1]);
-  nName = (int)strlen(argv[2]);
+  nDb = strlen(argv[1]);
+  nName = strlen(argv[2]);
   pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree)+nDb+nName+2);
   if( !pRtree ){
     return SQLITE_NOMEM;
diff --git a/src/build.c b/src/build.c
index 3c91cdc..cf4be29 100644
--- a/src/build.c
+++ b/src/build.c
@@ -3068,9 +3068,9 @@ void *sqlite3ArrayAllocate(
   int *pIdx         /* Write the index of a new slot here */
 ){
   char *z;
-  int n = *pnEntry;
+  sqlite3_int64 n = *pnEntry;
   if( (n & (n-1))==0 ){
-    int sz = (n==0) ? 1 : 2*n;
+    sqlite3_int64 sz = (n==0) ? 1 : 2*n;
     void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
     if( pNew==0 ){
       *pIdx = -1;
@@ -3174,7 +3174,7 @@ SrcList *sqlite3SrcListEnlarge(
   /* Allocate additional space if needed */
   if( pSrc->nSrc+nExtra>pSrc->nAlloc ){
     SrcList *pNew;
-    int nAlloc = pSrc->nSrc+nExtra;
+    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;
     int nGot;
     pNew = sqlite3DbRealloc(db, pSrc,
                sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
diff --git a/src/expr.c b/src/expr.c
index 660397e..648b606 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -1052,7 +1052,7 @@ ExprList *sqlite3ExprListAppend(
   }else if( (pList->nExpr & (pList->nExpr-1))==0 ){
     struct ExprList_item *a;
     assert( pList->nExpr>0 );
-    a = sqlite3DbRealloc(db, pList->a, pList->nExpr*2*sizeof(pList->a[0]));
+    a = sqlite3DbRealloc(db, pList->a, (sqlite3_int64)pList->nExpr*2*sizeof(pList->a[0]));
     if( a==0 ){
       goto no_mem;
     }
diff --git a/src/main.c b/src/main.c
index 39f6042..dafcf9a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -552,7 +552,7 @@ static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
     pStart = 0;
   }else if( pBuf==0 ){
     sqlite3BeginBenignMalloc();
-    pStart = sqlite3Malloc( sz*cnt );  /* IMP: R-61949-35727 */
+    pStart = sqlite3Malloc( sz*(sqlite3_int64)cnt );  /* IMP: R-61949-35727 */
     sqlite3EndBenignMalloc();
     if( pStart ) cnt = sqlite3MallocSize(pStart)/sz;
   }else{
diff --git a/src/test_fs.c b/src/test_fs.c
index 478cad8..25bf7bc 100644
--- a/src/test_fs.c
+++ b/src/test_fs.c
@@ -201,7 +201,7 @@ static int fsColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
     fstat(fd, &sbuf);
 
     if( sbuf.st_size>=pCur->nAlloc ){
-      int nNew = sbuf.st_size*2;
+      sqlite3_int64 nNew = sbuf.st_size*2;
       char *zNew;
       if( nNew<1024 ) nNew = 1024;
 
diff --git a/src/vdbeaux.c b/src/vdbeaux.c
index 2c4269a..ffedbfd 100644
--- a/src/vdbeaux.c
+++ b/src/vdbeaux.c
@@ -98,7 +98,7 @@ void sqlite3VdbeTrace(Vdbe *p, FILE *trace){
 */
 static int growOpArray(Vdbe *p){
   VdbeOp *pNew;
-  int nNew = (p->nOpAlloc ? p->nOpAlloc*2 : (int)(1024/sizeof(Op)));
+  sqlite3_int64 nNew = (p->nOpAlloc ? 2*(sqlite3_int64)p->nOpAlloc : (sqlite3_int64)(1024/sizeof(Op)));
   pNew = sqlite3DbRealloc(p->db, p->aOp, nNew*sizeof(Op));
   if( pNew ){
     p->nOpAlloc = sqlite3DbMallocSize(p->db, pNew)/sizeof(Op);
diff --git a/src/vdbesort.c b/src/vdbesort.c
index fdfc4a7..d3b3ded 100644
--- a/src/vdbesort.c
+++ b/src/vdbesort.c
@@ -222,7 +222,7 @@ static int vdbeSorterIterRead(
 
     /* Extend the p->aAlloc[] allocation if required. */
     if( p->nAlloc<nByte ){
-      int nNew = p->nAlloc*2;
+      sqlite3_int64 nNew = (sqlite3_int64)p->nAlloc*2;
       while( nByte>nNew ) nNew = nNew*2;
       p->aAlloc = sqlite3DbReallocOrFree(db, p->aAlloc, nNew);
       if( !p->aAlloc ) return SQLITE_NOMEM;
diff --git a/src/vtab.c b/src/vtab.c
index 958202c..1eb6d3a 100644
--- a/src/vtab.c
+++ b/src/vtab.c
@@ -276,10 +276,14 @@ void sqlite3VtabClear(sqlite3 *db, Table *p){
 ** string will be freed automatically when the table is
 ** deleted.
 */
-static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){
+static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){
   int i = pTable->nModuleArg++;
-  int nBytes = sizeof(char *)*(1+pTable->nModuleArg);
+  sqlite3_int64 nBytes = sizeof(char *)*(1+pTable->nModuleArg);
   char **azModuleArg;
+  sqlite3 *db = pParse->db;
+  if( pTable->nModuleArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){
+    sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);
+  }
   azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
   if( azModuleArg==0 ){
     int j;
@@ -323,9 +327,9 @@ void sqlite3VtabBeginParse(
 
   pTable->tabFlags |= TF_Virtual;
   pTable->nModuleArg = 0;
-  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));
-  addModuleArgument(db, pTable, 0);
-  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));
+  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
+  addModuleArgument(pParse, pTable, 0);
+  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));
   pParse->sNameToken.n = (int)(&pModuleName->z[pModuleName->n] - pName1->z);
 
 #ifndef SQLITE_OMIT_AUTHORIZATION
@@ -351,7 +355,7 @@ static void addArgumentToVtab(Parse *pParse){
     const char *z = (const char*)pParse->sArg.z;
     int n = pParse->sArg.n;
     sqlite3 *db = pParse->db;
-    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
+    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
   }
 }
 
@@ -620,7 +624,7 @@ static int growVTrans(sqlite3 *db){
   /* Grow the sqlite3.aVTrans array if required */
   if( (db->nVTrans%ARRAY_INCR)==0 ){
     VTable **aVTrans;
-    int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR);
+    sqlite3_int64 nBytes = sizeof(sqlite3_vtab *) * ((sqlite3_int64)db->nVTrans + ARRAY_INCR);
     aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
     if( !aVTrans ){
       return SQLITE_NOMEM;
-- 

