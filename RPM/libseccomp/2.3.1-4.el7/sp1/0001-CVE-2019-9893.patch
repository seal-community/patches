From 8b6d7180417f73673b70165606fe4e3ee5ae75d6 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Thu, 7 Dec 2023 11:52:12 +0200
Subject: [PATCH 1/1] Seal Security Hotfix for libseccomp 2.3.1-4.el7

This patch fixes:
  CVE-2019-9893

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://git.centos.org/rpms/libseccomp/tree/ac1c1653ea6f74d378efd985d94d0a7b14a890a8
---
 configure                          |   3 +-
 src/db.c                           | 387 +++++++++++++++++++++++------
 src/db.h                           |   4 +
 src/gen_bpf.c                      |  12 +-
 tests/34-sim-64b_comparisons.c     |  56 +++++
 tests/34-sim-64b_comparisons.py    |  45 ++++
 tests/34-sim-64b_comparisons.tests |  25 ++
 tests/Makefile.am                  |   9 +-
 tests/regression                   |  17 ++
 9 files changed, 478 insertions(+), 80 deletions(-)
 create mode 100644 tests/34-sim-64b_comparisons.c
 create mode 100644 tests/34-sim-64b_comparisons.py
 create mode 100644 tests/34-sim-64b_comparisons.tests

diff --git a/configure b/configure
index 21b0b14..48605d4 100755
--- a/configure
+++ b/configure
@@ -2166,7 +2166,8 @@ ac_config_headers="$ac_config_headers configure.h"
 
 
 
-am__api_version='1.14'
+am__api_version='1.13'
+aclocal
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
diff --git a/src/db.c b/src/db.c
index 1a85b1f..d0d5d9a 100644
--- a/src/db.c
+++ b/src/db.c
@@ -50,6 +50,14 @@ struct db_prune_state {
 	bool matched;
 };
 
+
+static struct db_arg_chain_tree *_db_node_get(struct db_arg_chain_tree *node)
+{
+	if (node != NULL)
+		node->refcnt++;
+	return node;
+}
+
 static unsigned int _db_tree_free(struct db_arg_chain_tree *tree);
 
 /**
@@ -994,9 +1002,12 @@ static struct db_sys_list *_db_rule_gen_64(const struct arch_def *arch,
 	unsigned int iter;
 	int chain_len_max;
 	struct db_sys_list *s_new;
-	struct db_arg_chain_tree *c_iter_hi = NULL, *c_iter_lo = NULL;
-	struct db_arg_chain_tree *c_prev_hi = NULL, *c_prev_lo = NULL;
-	bool tf_flag;
+	struct db_arg_chain_tree *c_iter[3] = { NULL, NULL, NULL };
+	struct db_arg_chain_tree *c_prev[3] = { NULL, NULL, NULL };
+	enum scmp_compare op_prev = _SCMP_CMP_MIN;
+	unsigned int arg;
+	scmp_datum_t mask;
+	scmp_datum_t datum;
 
 	s_new = malloc(sizeof(*s_new));
 	if (s_new == NULL)
@@ -1019,89 +1030,316 @@ static struct db_sys_list *_db_rule_gen_64(const struct arch_def *arch,
 		    !_db_arg_cmp_need_lo(&chain[iter]))
 			continue;
 
-		c_iter_hi = malloc(sizeof(*c_iter_hi));
-		if (c_iter_hi == NULL)
+		c_iter[0] = malloc(sizeof(*c_iter[0]));
+		if (c_iter[0] == NULL)
 			goto gen_64_failure;
-		memset(c_iter_hi, 0, sizeof(*c_iter_hi));
-		c_iter_hi->refcnt = 1;
-		c_iter_lo = malloc(sizeof(*c_iter_lo));
-		if (c_iter_lo == NULL) {
-			free(c_iter_hi);
+		memset(c_iter[0], 0, sizeof(*c_iter[0]));
+		c_iter[0]->refcnt = 0;
+		c_iter[1] = malloc(sizeof(*c_iter[1]));
+		if (c_iter[1] == NULL) {
+			free(c_iter[0]);
 			goto gen_64_failure;
 		}
-		memset(c_iter_lo, 0, sizeof(*c_iter_lo));
-		c_iter_lo->refcnt = 1;
-
-		/* link this level to the previous level */
-		if (c_prev_lo != NULL) {
-			if (!tf_flag) {
-				c_prev_lo->nxt_f = c_iter_hi;
-				c_prev_hi->nxt_f = c_iter_hi;
-				c_iter_hi->refcnt++;
-			} else
-				c_prev_lo->nxt_t = c_iter_hi;
-		} else
-			s_new->chains = c_iter_hi;
-		s_new->node_cnt += 2;
-
-		/* set the arg, op, and datum fields */
-		c_iter_hi->arg = chain[iter].arg;
-		c_iter_lo->arg = chain[iter].arg;
-		c_iter_hi->arg_offset = arch_arg_offset_hi(arch,
-							   c_iter_hi->arg);
-		c_iter_lo->arg_offset = arch_arg_offset_lo(arch,
-							   c_iter_lo->arg);
+		memset(c_iter[1], 0, sizeof(*c_iter[1]));
+		c_iter[1]->refcnt = 0;
+
+		c_iter[2] = NULL;
+
+		arg = chain[iter].arg;
+		mask = chain[iter].mask;
+		datum = chain[iter].datum;
+
+		/* NOTE: with the idea that a picture is worth a thousand
+		 *       words, i'm presenting the following diagrams which
+		 *       show how we should compare 64-bit syscall arguments
+		 *       using 32-bit comparisons.
+		 *
+		 *       in the diagrams below "A(x)" is the syscall argument
+		 *       being evaluated and "R(x)" is the syscall argument
+		 *       value specified in the libseccomp rule.  the "ACCEPT"
+		 *       verdict indicates a rule match and processing should
+		 *       continue on to the rest of the rule, or the final rule
+		 *       action should be triggered.  the "REJECT" verdict
+		 *       indicates that the rule does not match and processing
+		 *       should continue to the next rule or the default
+		 *       action.
+		 *
+		 * SCMP_CMP_GT:
+		 *                   +------------------+
+		 *                +--|  Ah(x) >  Rh(x)  |------+
+		 *                |  +------------------+      |
+		 *              FALSE                         TRUE     A
+		 *                |                            |       C
+		 *                +-----------+                +---->  C
+		 *                            v                +---->  E
+		 *                   +------------------+      |       P
+		 *                +--|  Ah(x) == Rh(x)  |--+   |       T
+		 *        R       |  +------------------+  |   |
+		 *        E     FALSE                     TRUE |
+		 *        J  <----+                        |   |
+		 *        E  <----+           +------------+   |
+		 *        C     FALSE         v                |
+		 *        T       |  +------------------+      |
+		 *                +--|  Al(x) >  Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 * SCMP_CMP_GE:
+		 *                   +------------------+
+		 *                +--|  Ah(x) >  Rh(x)  |------+
+		 *                |  +------------------+      |
+		 *              FALSE                         TRUE     A
+		 *                |                            |       C
+		 *                +-----------+                +---->  C
+		 *                            v                +---->  E
+		 *                   +------------------+      |       P
+		 *                +--|  Ah(x) == Rh(x)  |--+   |       T
+		 *        R       |  +------------------+  |   |
+		 *        E     FALSE                     TRUE |
+		 *        J  <----+                        |   |
+		 *        E  <----+           +------------+   |
+		 *        C     FALSE         v                |
+		 *        T       |  +------------------+      |
+		 *                +--|  Al(x) >= Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 * SCMP_CMP_LT:
+		 *                   +------------------+
+		 *                +--|  Ah(x) >  Rh(x)  |------+
+		 *                |  +------------------+      |
+		 *              FALSE                         TRUE     R
+		 *                |                            |       E
+		 *                +-----------+                +---->  J
+		 *                            v                +---->  E
+		 *                   +------------------+      |       C
+		 *                +--|  Ah(x) == Rh(x)  |--+   |       T
+		 *        A       |  +------------------+  |   |
+		 *        C     FALSE                     TRUE |
+		 *        C  <----+                        |   |
+		 *        E  <----+           +------------+   |
+		 *        P     FALSE         v                |
+		 *        T       |  +------------------+      |
+		 *                +--|  Al(x) >= Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 * SCMP_CMP_LE:
+		 *                   +------------------+
+		 *                +--|  Ah(x) >  Rh(x)  |------+
+		 *                |  +------------------+      |
+		 *              FALSE                         TRUE     R
+		 *                |                            |       E
+		 *                +-----------+                +---->  J
+		 *                            v                +---->  E
+		 *                   +------------------+      |       C
+		 *                +--|  Ah(x) == Rh(x)  |--+   |       T
+		 *        A       |  +------------------+  |   |
+		 *        C     FALSE                     TRUE |
+		 *        C  <----+                        |   |
+		 *        E  <----+           +------------+   |
+		 *        P     FALSE         v                |
+		 *        T       |  +------------------+      |
+		 *                +--|  Al(x) >  Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 * SCMP_CMP_EQ:
+		 *                   +------------------+
+		 *                +--|  Ah(x) == Rh(x)  |--+
+		 *        R       |  +------------------+  |           A
+		 *        E     FALSE                     TRUE         C
+		 *        J  <----+                        |           C
+		 *        E  <----+           +------------+   +---->  E
+		 *        C     FALSE         v                |       P
+		 *        T       |  +------------------+      |       T
+		 *                +--|  Al(x) == Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 * SCMP_CMP_NE:
+		 *                   +------------------+
+		 *                +--|  Ah(x) == Rh(x)  |--+
+		 *        A       |  +------------------+  |           R
+		 *        C     FALSE                     TRUE         E
+		 *        C  <----+                        |           J
+		 *        E  <----+           +------------+   +---->  E
+		 *        P     FALSE         v                |       C
+		 *        T       |  +------------------+      |       T
+		 *                +--|  Al(x) == Rl(x)  |------+
+		 *                   +------------------+
+		 *
+		 */
+
+		/* setup the level */
 		switch (chain[iter].op) {
 		case SCMP_CMP_GT:
-			c_iter_hi->op = SCMP_CMP_GE;
-			c_iter_lo->op = SCMP_CMP_GT;
-			tf_flag = true;
-			break;
-		case SCMP_CMP_NE:
-			c_iter_hi->op = SCMP_CMP_EQ;
-			c_iter_lo->op = SCMP_CMP_EQ;
-			tf_flag = false;
-			break;
+		case SCMP_CMP_GE:
+		case SCMP_CMP_LE:
 		case SCMP_CMP_LT:
-			c_iter_hi->op = SCMP_CMP_GE;
-			c_iter_lo->op = SCMP_CMP_GE;
-			tf_flag = false;
+			c_iter[2] = malloc(sizeof(*c_iter[2]));
+			memset(c_iter[2], 0, sizeof(*c_iter[2]));
+			if (c_iter[2] == NULL) {
+				free(c_iter[0]);
+				free(c_iter[1]);
+				goto gen_64_failure;
+			}
+
+			c_iter[0]->arg = arg;
+			c_iter[1]->arg = arg;
+			c_iter[2]->arg = arg;
+			c_iter[0]->arg_h_flg = true;
+			c_iter[1]->arg_h_flg = true;
+			c_iter[2]->arg_h_flg = false;
+			c_iter[0]->arg_offset = arch_arg_offset_hi(arch, arg);
+			c_iter[1]->arg_offset = arch_arg_offset_hi(arch, arg);
+			c_iter[2]->arg_offset = arch_arg_offset_lo(arch, arg);
+
+			c_iter[0]->mask = D64_HI(mask);
+			c_iter[1]->mask = D64_HI(mask);
+			c_iter[2]->mask = D64_LO(mask);
+			c_iter[0]->datum = D64_HI(datum);
+			c_iter[1]->datum = D64_HI(datum);
+			c_iter[2]->datum = D64_LO(datum);
+			c_iter[0]->datum_full = datum;
+			c_iter[1]->datum_full = datum;
+			c_iter[2]->datum_full = datum;
+
+			_db_node_mask_fixup(c_iter[0]);
+			_db_node_mask_fixup(c_iter[1]);
+			_db_node_mask_fixup(c_iter[2]);
+
+			c_iter[0]->op = SCMP_CMP_GT;
+			c_iter[1]->op = SCMP_CMP_EQ;
+			switch (chain[iter].op) {
+			case SCMP_CMP_GT:
+			case SCMP_CMP_LE:
+				c_iter[2]->op = SCMP_CMP_GT;
+				break;
+			case SCMP_CMP_GE:
+			case SCMP_CMP_LT:
+				c_iter[2]->op = SCMP_CMP_GE;
+				break;
+			default:
+				/* we should never get here */
+				goto gen_64_failure;
+			}
+			c_iter[0]->op_orig = chain[iter].op;
+			c_iter[1]->op_orig = chain[iter].op;
+			c_iter[2]->op_orig = chain[iter].op;
+
+			c_iter[0]->nxt_f = _db_node_get(c_iter[1]);
+			c_iter[1]->nxt_t = _db_node_get(c_iter[2]);
 			break;
-		case SCMP_CMP_LE:
-			c_iter_hi->op = SCMP_CMP_GE;
-			c_iter_lo->op = SCMP_CMP_GT;
-			tf_flag = false;
+		case SCMP_CMP_EQ:
+		case SCMP_CMP_MASKED_EQ:
+		case SCMP_CMP_NE:
+			c_iter[0]->arg = arg;
+			c_iter[1]->arg = arg;
+			c_iter[0]->arg_h_flg = true;
+			c_iter[1]->arg_h_flg = false;
+			c_iter[0]->arg_offset = arch_arg_offset_hi(arch, arg);
+			c_iter[1]->arg_offset = arch_arg_offset_lo(arch, arg);
+
+			c_iter[0]->mask = D64_HI(mask);
+			c_iter[1]->mask = D64_LO(mask);
+			c_iter[0]->datum = D64_HI(datum);
+			c_iter[1]->datum = D64_LO(datum);
+			c_iter[0]->datum_full = datum;
+			c_iter[1]->datum_full = datum;
+
+			_db_node_mask_fixup(c_iter[0]);
+			_db_node_mask_fixup(c_iter[1]);
+
+			switch (chain[iter].op) {
+			case SCMP_CMP_MASKED_EQ:
+				c_iter[0]->op = SCMP_CMP_MASKED_EQ;
+				c_iter[1]->op = SCMP_CMP_MASKED_EQ;
+				break;
+			default:
+				c_iter[0]->op = SCMP_CMP_EQ;
+				c_iter[1]->op = SCMP_CMP_EQ;
+			}
+			c_iter[0]->op_orig = chain[iter].op;
+			c_iter[1]->op_orig = chain[iter].op;
+
+			c_iter[0]->nxt_t = _db_node_get(c_iter[1]);
 			break;
 		default:
-			c_iter_hi->op = chain[iter].op;
-			c_iter_lo->op = chain[iter].op;
-			tf_flag = true;
+			/* we should never get here */
+			goto gen_64_failure;
 		}
-		c_iter_hi->mask = D64_HI(chain[iter].mask);
-		c_iter_lo->mask = D64_LO(chain[iter].mask);
-		c_iter_hi->datum = D64_HI(chain[iter].datum);
-		c_iter_lo->datum = D64_LO(chain[iter].datum);
-
-		/* fixup the mask/datum */
-		_db_node_mask_fixup(c_iter_hi);
-		_db_node_mask_fixup(c_iter_lo);
+		/* link this level to the previous level */
+		if (c_prev[0] != NULL) {
+			switch (op_prev) {
+			case SCMP_CMP_GT:
+			case SCMP_CMP_GE:
+				c_prev[0]->nxt_t = _db_node_get(c_iter[0]);
+				c_prev[2]->nxt_t = _db_node_get(c_iter[0]);
+				break;
+			case SCMP_CMP_EQ:
+			case SCMP_CMP_MASKED_EQ:
+				c_prev[1]->nxt_t = _db_node_get(c_iter[0]);
+				break;
+			case SCMP_CMP_LE:
+			case SCMP_CMP_LT:
+				c_prev[1]->nxt_f = _db_node_get(c_iter[0]);
+				c_prev[2]->nxt_f = _db_node_get(c_iter[0]);
+				break;
+			case SCMP_CMP_NE:
+				c_prev[0]->nxt_f = _db_node_get(c_iter[0]);
+				c_prev[1]->nxt_f = _db_node_get(c_iter[0]);
+				break;
+			default:
+				/* we should never get here */
+				goto gen_64_failure;
+			}
+		} else
+			s_new->chains = _db_node_get(c_iter[0]);
 
-		/* link the hi and lo chain nodes */
-		c_iter_hi->nxt_t = c_iter_lo;
+		/* update the node count */
+		switch (chain[iter].op) {
+		case SCMP_CMP_NE:
+		case SCMP_CMP_EQ:
+		case SCMP_CMP_MASKED_EQ:
+			s_new->node_cnt += 2;
+			break;
+		default:
+			s_new->node_cnt += 3;
+		}
 
-		c_prev_hi = c_iter_hi;
-		c_prev_lo = c_iter_lo;
+		/* keep pointers to this level */
+		c_prev[0] = c_iter[0];
+		c_prev[1] = c_iter[1];
+		c_prev[2] = c_iter[2];
+		op_prev = chain[iter].op;
 	}
-	if (c_iter_lo != NULL) {
-		/* set the leaf node */
-		if (!tf_flag) {
-			c_iter_lo->act_f_flg = true;
-			c_iter_lo->act_f = action;
-			c_iter_hi->act_f_flg = true;
-			c_iter_hi->act_f = action;
-		} else {
-			c_iter_lo->act_t_flg = true;
-			c_iter_lo->act_t = action;
+	if (c_iter[0] != NULL) {
+		/* set the actions on the last layer */
+		switch (op_prev) {
+		case SCMP_CMP_GT:
+		case SCMP_CMP_GE:
+			c_iter[0]->act_t_flg = true;
+			c_iter[0]->act_t = action;
+			c_iter[2]->act_t_flg = true;
+			c_iter[2]->act_t = action;
+			break;
+		case SCMP_CMP_LE:
+		case SCMP_CMP_LT:
+			c_iter[1]->act_f_flg = true;
+			c_iter[1]->act_f = action;
+			c_iter[2]->act_f_flg = true;
+			c_iter[2]->act_f = action;
+			break;
+		case SCMP_CMP_EQ:
+		case SCMP_CMP_MASKED_EQ:
+			c_iter[1]->act_t_flg = true;
+			c_iter[1]->act_t = action;
+			break;
+		case SCMP_CMP_NE:
+			c_iter[0]->act_f_flg = true;
+			c_iter[0]->act_f = action;
+			c_iter[1]->act_f_flg = true;
+			c_iter[1]->act_f = action;
+			break;
+		default:
+			/* we should never get here */
+			goto gen_64_failure;
 		}
 	} else
 		s_new->action = action;
@@ -1161,11 +1399,14 @@ static struct db_sys_list *_db_rule_gen_32(const struct arch_def *arch,
 		memset(c_iter, 0, sizeof(*c_iter));
 		c_iter->refcnt = 1;
 		c_iter->arg = chain[iter].arg;
+		c_iter->arg_h_flg = false;
 		c_iter->arg_offset = arch_arg_offset(arch, c_iter->arg);
 		c_iter->op = chain[iter].op;
+		c_iter->op_orig = chain[iter].op;
 		/* implicitly strips off the upper 32 bit */
 		c_iter->mask = chain[iter].mask;
 		c_iter->datum = chain[iter].datum;
+		c_iter->datum_full = chain[iter].datum;
 
 		/* link in the new node and update the chain */
 		if (c_prev != NULL) {
diff --git a/src/db.h b/src/db.h
index 1f67b5d..5887a87 100644
--- a/src/db.h
+++ b/src/db.h
@@ -52,14 +52,18 @@ struct db_api_rule_list {
 struct db_arg_chain_tree {
 	/* argument number (a0 = 0, a1 = 1, etc.) */
 	unsigned int arg;
+	/* true to indicate this is the high 32-bit word of a 64-bit value */
+	bool arg_h_flg;
 	/* argument bpf offset */
 	unsigned int arg_offset;
 
 	/* comparison operator */
 	enum scmp_compare op;
+	enum scmp_compare op_orig;
 	/* syscall argument value */
 	uint32_t mask;
 	uint32_t datum;
+	scmp_datum_t datum_full;
 
 	/* actions */
 	bool act_t_flg;
diff --git a/src/gen_bpf.c b/src/gen_bpf.c
index 2418a1a..954924a 100644
--- a/src/gen_bpf.c
+++ b/src/gen_bpf.c
@@ -859,6 +859,13 @@ static struct bpf_blk *_gen_bpf_node(struct bpf_state *state,
 			goto node_failure;
 	}
 
+	/* set the accumulator state at the end of the block */
+	/* NOTE: the accumulator end state is very critical when we are
+	 *       assembling the final state; we assume that however we leave
+	 *       this instruction block the accumulator state is represented
+	 *       by blk->acc_end, it must be kept correct */
+	blk->acc_end = *a_state;
+
 	/* check the accumulator against the datum */
 	switch (node->op) {
 	case SCMP_CMP_MASKED_EQ:
@@ -903,7 +910,6 @@ static struct bpf_blk *_gen_bpf_node(struct bpf_state *state,
 		goto node_failure;
 
 	blk->node = node;
-	blk->acc_end = *a_state;
 	return blk;
 
 node_failure:
@@ -958,7 +964,7 @@ static struct bpf_blk *_gen_bpf_chain_lvl_res(struct bpf_state *state,
 		case TGT_PTR_DB:
 			node = (struct db_arg_chain_tree *)i_iter->jt.tgt.db;
 			b_new = _gen_bpf_chain(state, sys, node,
-					       nxt_jump, &blk->acc_start);
+					       nxt_jump, &blk->acc_end);
 			if (b_new == NULL)
 				return NULL;
 			i_iter->jt = _BPF_JMP_HSH(b_new->hash);
@@ -984,7 +990,7 @@ static struct bpf_blk *_gen_bpf_chain_lvl_res(struct bpf_state *state,
 		case TGT_PTR_DB:
 			node = (struct db_arg_chain_tree *)i_iter->jf.tgt.db;
 			b_new = _gen_bpf_chain(state, sys, node,
-					       nxt_jump, &blk->acc_start);
+					       nxt_jump, &blk->acc_end);
 			if (b_new == NULL)
 				return NULL;
 			i_iter->jf = _BPF_JMP_HSH(b_new->hash);
diff --git a/tests/34-sim-64b_comparisons.c b/tests/34-sim-64b_comparisons.c
new file mode 100644
index 0000000..364a67d
--- /dev/null
+++ b/tests/34-sim-64b_comparisons.c
@@ -0,0 +1,56 @@
+/**
+ * Seccomp Library test program
+ *
+ * Copyright (c) 2019 Cisco Systems, Inc. <pmoore2@cisco.com>
+ * Author: Paul Moore <paul@paul-moore.com>
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; if not, see <http://www.gnu.org/licenses>.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <seccomp.h>
+
+#include "util.h"
+
+int main(int argc, char *argv[])
+{
+	int rc;
+	struct util_options opts;
+	scmp_filter_ctx ctx = NULL;
+
+	rc = util_getopt(argc, argv, &opts);
+	if (rc < 0)
+		goto out;
+
+	ctx = seccomp_init(SCMP_ACT_KILL);
+	if (ctx == NULL)
+		return ENOMEM;
+
+
+	rc = seccomp_rule_add_exact(ctx, SCMP_ACT_ALLOW, 1000, 1,
+				    SCMP_A0(SCMP_CMP_LT, 0x123456789abcUL));
+	if (rc != 0)
+		goto out;
+
+	rc = util_filter_output(&opts, ctx);
+	if (rc)
+		goto out;
+
+out:
+	seccomp_release(ctx);
+	return (rc < 0 ? -rc : rc);
+}
diff --git a/tests/34-sim-64b_comparisons.py b/tests/34-sim-64b_comparisons.py
new file mode 100644
index 0000000..054cdea
--- /dev/null
+++ b/tests/34-sim-64b_comparisons.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python
+
+#
+# Seccomp Library test program
+#
+# Copyright (c) 2019 Cisco Systems, Inc. <pmoore2@cisco.com>
+# Author: Paul Moore <paul@paul-moore.com>
+#
+
+#
+# This library is free software; you can redistribute it and/or modify it
+# under the terms of version 2.1 of the GNU Lesser General Public License as
+# published by the Free Software Foundation.
+#
+# This library is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+# for more details.
+#
+# You should have received a copy of the GNU Lesser General Public License
+# along with this library; if not, see <http://www.gnu.org/licenses>.
+#
+
+import argparse
+import errno
+import sys
+
+import util
+
+from seccomp import *
+
+def test(args):
+    set_api(3)
+
+    f = SyscallFilter(KILL)
+    f.add_rule_exactly(ALLOW, 1000, Arg(0, LT, 0x123456789abc))
+
+    return f
+
+args = util.get_opt()
+ctx = test(args)
+util.filter_output(args, ctx)
+
+# kate: syntax python;
+# kate: indent-mode python; space-indent on; indent-width 4; mixedindent off;
diff --git a/tests/34-sim-64b_comparisons.tests b/tests/34-sim-64b_comparisons.tests
new file mode 100644
index 0000000..93e533a
--- /dev/null
+++ b/tests/34-sim-64b_comparisons.tests
@@ -0,0 +1,25 @@
+#
+# libseccomp regression test automation data
+#
+# Copyright (c) 2019 Cisco Systems, Inc. <pmoore2@cisco.com>
+# Author: Paul Moore <paul@paul-moore.com>
+#
+
+test type: bpf-sim
+
+# Testname		Arch	Syscall	Arg0		Arg1	Arg2	Arg3	Arg4	Arg5	Result
+34-sim-64b_comparisons	all_64	1000	0x000000000000	N	N	N	N	N	ALLOW
+34-sim-64b_comparisons	all_64	1000	0x123000000000	N	N	N	N	N	ALLOW
+34-sim-64b_comparisons	all_64	1000	0x1230f0000000	N	N	N	N	N	ALLOW
+34-sim-64b_comparisons	all_64	1000	0x123400000000	N	N	N	N	N	ALLOW
+34-sim-64b_comparisons	all_64	1000	0x123450000000	N	N	N	N	N	ALLOW
+34-sim-64b_comparisons	all_64	1000	0x123460000000	N	N	N	N	N	KILL
+34-sim-64b_comparisons	all_64	1000	0x1234f0000000	N	N	N	N	N	KILL
+34-sim-64b_comparisons	all_64	1000	0x123500000000	N	N	N	N	N	KILL
+34-sim-64b_comparisons	all_64	1000	0x1235f0000000	N	N	N	N	N	KILL
+34-sim-64b_comparisons	all_64	1000	0x123600000000	N	N	N	N	N	KILL
+
+test type: bpf-valgrind
+
+# Testname
+34-sim-64b_comparisons
diff --git a/tests/Makefile.am b/tests/Makefile.am
index ee4e41b..ffde79f 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -61,7 +61,8 @@ check_PROGRAMS = \
 	30-sim-socket_syscalls \
 	31-basic-version_check \
 	32-live-tsync_allow \
-	33-sim-socket_syscalls_be
+	33-sim-socket_syscalls_be \
+	34-sim-64b_comparisons
 
 EXTRA_DIST_TESTPYTHON = \
 	util.py \
@@ -97,7 +98,8 @@ EXTRA_DIST_TESTPYTHON = \
 	30-sim-socket_syscalls.py \
 	31-basic-version_check.py \
 	32-live-tsync_allow.py \
-	33-sim-socket_syscalls_be.py
+	33-sim-socket_syscalls_be.py \
+	34-sim-64b_comparisons.py
 
 EXTRA_DIST_TESTCFGS = \
 	01-sim-allow.tests \
@@ -132,7 +134,8 @@ EXTRA_DIST_TESTCFGS = \
 	30-sim-socket_syscalls.tests \
 	31-basic-version_check.tests \
 	32-live-tsync_allow.tests \
-	33-sim-socket_syscalls_be.tests
+	33-sim-socket_syscalls_be.tests \
+	34-sim-64b_comparisons.tests
 
 EXTRA_DIST_TESTSCRIPTS = regression testdiff testgen
 
diff --git a/tests/regression b/tests/regression
index 53d26b2..dd69b6d 100755
--- a/tests/regression
+++ b/tests/regression
@@ -30,6 +30,13 @@ GLBL_ARCH_BE_SUPPORT=" \
 	mips mips64 mips64n32 \
 	ppc ppc64 \
 	s390 s390x"
+GLBL_ARCH_64B_SUPPORT=" \
+	x86_64 \
+	aarch64 \
+	mips64 \
+	ppc64 \
+	s390x"
+
 
 GLBL_SYS_ARCH="../tools/scmp_arch_detect"
 GLBL_SYS_RESOLVER="../tools/scmp_sys_resolver"
@@ -407,6 +414,16 @@ function run_test_bpf_sim() {
 			# add all of the big endian architectures
 			simarch_tmp+=" $GLBL_ARCH_BE_SUPPORT"
 			;;
+		all_64)
+			# add the native arch only if it is 64-bit
+			if echo "$GLBL_ARCH_64B_SUPPORT" | grep -qw "$arch"; then
+				simarch_tmp+=" $arch"
+			fi
+			;;
+		+all_64)
+			# add all of the 64-bit architectures
+			simarch_tmp+=" $GLBL_ARCH_64B_SUPPORT"
+			;;
 		+*)
 			# add the architecture specified
 			simarch_tmp+=" ${arch_i:1}"
-- 

