From dfaa60e3965e0ed538f3e933694d40b1088f3638 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Sun, 24 Dec 2023 17:00:26 +0200
Subject: [PATCH 1/1] Seal Security Hotfix for grub2-pc-modules 1:2.02-0.87.el7.centos.6

This patch fixes:
  CVE-2022-2601
  CVE-2022-3775

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://git.centos.org/rpms/grub2/tree/ae9b54f7e9639d890bb43a330ea020ea7738326a
---
 grub-core/font/font.c       | 163 +++++++++++++++++++++---------------
 grub-core/normal/charset.c  |   3 +
 grub-core/video/fb/fbutil.c |   4 +-
 include/grub/bitmap.h       |  18 ++++
 include/grub/fbutil.h       |  13 ++-
 include/grub/safemath.h     |   4 +
 include/grub/unicode.h      |   2 +
 7 files changed, 134 insertions(+), 73 deletions(-)

diff --git a/grub-core/font/font.c b/grub-core/font/font.c
index 1239ac5..d02da9d 100644
--- a/grub-core/font/font.c
+++ b/grub-core/font/font.c
@@ -137,7 +137,7 @@ ascii_glyph_lookup (grub_uint32_t code)
 	  ascii_font_glyph[current]->offset_x = 0;
 	  ascii_font_glyph[current]->offset_y = -2;
 	  ascii_font_glyph[current]->device_width = 8;
-	  ascii_font_glyph[current]->font = NULL;
+	  ascii_font_glyph[current]->font = &null_font;
 
 	  grub_memcpy (ascii_font_glyph[current]->bitmap,
 		       &ascii_bitmaps[current * ASCII_BITMAP_SIZE],
@@ -300,6 +300,8 @@ load_font_index (grub_file_t file, grub_uint32_t sect_length, struct
   font->bmp_idx = grub_malloc (0x10000 * sizeof (grub_uint16_t));
   if (!font->bmp_idx)
     return 1;
+
+  /* Init the BMP index array to 0xffff. */
   grub_memset (font->bmp_idx, 0xff, 0x10000 * sizeof (grub_uint16_t));
 
 
@@ -328,7 +330,7 @@ load_font_index (grub_file_t file, grub_uint32_t sect_length, struct
 	  return 1;
 	}
 
-      if (entry->code < 0x10000)
+      if (entry->code < 0x10000 && i < 0xffff)
 	font->bmp_idx[entry->code] = i;
 
       last_code = entry->code;
@@ -686,40 +688,47 @@ read_be_int16 (grub_file_t file, grub_int16_t * value)
 static inline struct char_index_entry *
 find_glyph (const grub_font_t font, grub_uint32_t code)
 {
-  struct char_index_entry *table;
-  grub_size_t lo;
-  grub_size_t hi;
-  grub_size_t mid;
+  struct char_index_entry *table, *first, *end;
+  grub_size_t len;
 
   table = font->char_index;
+  if (table == NULL)
+    return NULL;
 
   /* Use BMP index if possible.  */
   if (code < 0x10000 && font->bmp_idx)
     {
-      if (font->bmp_idx[code] == 0xffff)
-	return 0;
-      return &table[font->bmp_idx[code]];
+      if (font->bmp_idx[code] < 0xffff)
+       return &table[font->bmp_idx[code]];
+      /*
+       * When we are here then lookup in BMP index result in miss,
+       * fallthough to binary-search.
+       */
     }
 
-  /* Do a binary search in `char_index', which is ordered by code point.  */
-  lo = 0;
-  hi = font->num_chars - 1;
+  /*
+   * Do a binary search in char_index which is ordered by code point.
+   * The code below is the same as libstdc++'s std::lower_bound().
+   */
+  first = table;
+  len = font->num_chars;
+  end = first + len;
 
-  if (!table)
-    return 0;
-
-  while (lo <= hi)
+  while (len > 0)
     {
-      mid = lo + (hi - lo) / 2;
-      if (code < table[mid].code)
-	hi = mid - 1;
-      else if (code > table[mid].code)
-	lo = mid + 1;
+      grub_size_t half = len >> 1;
+      struct char_index_entry *middle = first + half;
+
+      if (middle->code < code)
+       {
+         first = middle + 1;
+         len = len - half - 1;
+       }
       else
-	return &table[mid];
+	len = half;
     }
 
-  return 0;
+  return (first < end && first->code == code) ? first : NULL;
 }
 
 /* Get a glyph for the Unicode character CODE in FONT.  The glyph is loaded
@@ -739,7 +748,8 @@ grub_font_get_glyph_internal (grub_font_t font, grub_uint32_t code)
       grub_int16_t xoff;
       grub_int16_t yoff;
       grub_int16_t dwidth;
-      int len;
+      grub_ssize_t len;
+      grub_size_t sz;
 
       if (index_entry->glyph)
 	/* Return cached glyph.  */
@@ -760,15 +770,25 @@ grub_font_get_glyph_internal (grub_font_t font, grub_uint32_t code)
 	  || read_be_uint16 (font->file, &height) != 0
 	  || read_be_int16 (font->file, &xoff) != 0
 	  || read_be_int16 (font->file, &yoff) != 0
-	  || read_be_int16 (font->file, &dwidth) != 0)
+	  || read_be_int16 (font->file, &dwidth) != 0
+	  || width > font->max_char_width
+	  || height > font->max_char_height)
 	{
 	  remove_font (font);
 	  return 0;
 	}
 
-      len = (width * height + 7) / 8;
-      glyph = grub_malloc (sizeof (struct grub_font_glyph) + len);
-      if (!glyph)
+	/* Calculate real struct size of current glyph. */
+	if (grub_video_bitmap_calc_1bpp_bufsz (width, height, &len) ||
+	   grub_add (sizeof (struct grub_font_glyph), len, &sz))
+	{
+	   remove_font (font);
+	   return 0;
+	}
+
+	/* Allocate and initialize the glyph struct. */
+	glyph = grub_malloc (sz);
+	if (glyph == NULL)
 	{
 	  remove_font (font);
 	  return 0;
@@ -1043,27 +1063,20 @@ grub_font_get_glyph_with_fallback (grub_font_t font, grub_uint32_t code)
   return best_glyph;
 }
 
-#if 0
-static struct grub_font_glyph *
-grub_font_dup_glyph (struct grub_font_glyph *glyph)
-{
-  static struct grub_font_glyph *ret;
-  ret = grub_malloc (sizeof (*ret) + (glyph->width * glyph->height + 7) / 8);
-  if (!ret)
-    return NULL;
-  grub_memcpy (ret, glyph, sizeof (*ret)
-	       + (glyph->width * glyph->height + 7) / 8);
-  return ret;
-}
-#endif
-
 /* FIXME: suboptimal.  */
 static void
 grub_font_blit_glyph (struct grub_font_glyph *target,
 		      struct grub_font_glyph *src, unsigned dx, unsigned dy)
 {
+  grub_uint16_t max_x, max_y;
   unsigned src_bit, tgt_bit, src_byte, tgt_byte;
   unsigned i, j;
+
+  /* Harden against out-of-bound writes. */
+  if ((grub_add (dx, src->width, &max_x) || max_x > target->width) ||
+      (grub_add (dy, src->height, &max_y) || max_y > target->height))
+    return;
+
   for (i = 0; i < src->height; i++)
     {
       src_bit = (src->width * i) % 8;
@@ -1095,9 +1108,16 @@ grub_font_blit_glyph_mirror (struct grub_font_glyph *target,
 			     struct grub_font_glyph *src,
 			     unsigned dx, unsigned dy)
 {
+  grub_uint16_t max_x, max_y;
   unsigned tgt_bit, src_byte, tgt_byte;
   signed src_bit;
   unsigned i, j;
+
+  /* Harden against out-of-bound writes. */
+  if ((grub_add (dx, src->width, &max_x) || max_x > target->width) ||
+      (grub_add (dy, src->height, &max_y) || max_y > target->height))
+    return;
+
   for (i = 0; i < src->height; i++)
     {
       src_bit = (src->width * i + src->width - 1) % 8;
@@ -1196,12 +1216,12 @@ blit_comb (const struct grub_unicode_glyph *glyph_id,
   ctx.bounds.height = main_glyph->height;
 
   above_rightx = main_glyph->offset_x + main_glyph->width;
-  above_righty = ctx.bounds.y + ctx.bounds.height;
+  above_righty = ctx.bounds.y + (int) ctx.bounds.height;
 
   above_leftx = main_glyph->offset_x;
-  above_lefty = ctx.bounds.y + ctx.bounds.height;
+  above_lefty = ctx.bounds.y + (int) ctx.bounds.height;
 
-  below_rightx = ctx.bounds.x + ctx.bounds.width;
+  below_rightx = ctx.bounds.x + (int) ctx.bounds.width;
   below_righty = ctx.bounds.y;
 
   comb = grub_unicode_get_comb (glyph_id);
@@ -1214,7 +1234,7 @@ blit_comb (const struct grub_unicode_glyph *glyph_id,
 
       if (!combining_glyphs[i])
 	continue;
-      targetx = (ctx.bounds.width - combining_glyphs[i]->width) / 2 + ctx.bounds.x;
+      targetx = ((int) ctx.bounds.width - combining_glyphs[i]->width) / 2 + ctx.bounds.x;
       /* CGJ is to avoid diacritics reordering. */
       if (comb[i].code
 	  == GRUB_UNICODE_COMBINING_GRAPHEME_JOINER)
@@ -1224,8 +1244,8 @@ blit_comb (const struct grub_unicode_glyph *glyph_id,
 	case GRUB_UNICODE_COMB_OVERLAY:
 	  do_blit (combining_glyphs[i],
 		   targetx,
-		   (ctx.bounds.height - combining_glyphs[i]->height) / 2
-		   - (ctx.bounds.height + ctx.bounds.y), &ctx);
+		   ((int) ctx.bounds.height - combining_glyphs[i]->height) / 2
+		   - ((int) ctx.bounds.height + ctx.bounds.y), &ctx);
 	  if (min_devwidth < combining_glyphs[i]->width)
 	    min_devwidth = combining_glyphs[i]->width;
 	  break;
@@ -1298,7 +1318,7 @@ blit_comb (const struct grub_unicode_glyph *glyph_id,
 
 	case GRUB_UNICODE_STACK_ATTACHED_ABOVE:
 	  do_blit (combining_glyphs[i], targetx,
-		   -(ctx.bounds.height + ctx.bounds.y + space
+		   -((int) ctx.bounds.height + ctx.bounds.y + space
 		     + combining_glyphs[i]->height), &ctx);
 	  if (min_devwidth < combining_glyphs[i]->width)
 	    min_devwidth = combining_glyphs[i]->width;
@@ -1306,7 +1326,7 @@ blit_comb (const struct grub_unicode_glyph *glyph_id,
 
 	case GRUB_UNICODE_COMB_HEBREW_DAGESH:
 	  do_blit (combining_glyphs[i], targetx,
-		   -(ctx.bounds.height / 2 + ctx.bounds.y
+		   -((int) ctx.bounds.height / 2 + ctx.bounds.y
 		     + combining_glyphs[i]->height / 2), &ctx);
 	  if (min_devwidth < combining_glyphs[i]->width)
 	    min_devwidth = combining_glyphs[i]->width;
@@ -1469,14 +1489,18 @@ ensure_comb_space (const struct grub_unicode_glyph *glyph_id)
   if (glyph_id->ncomb <= render_max_comb_glyphs)
     return;
 
-  render_max_comb_glyphs = 2 * glyph_id->ncomb;
-  if (render_max_comb_glyphs < 8)
+  if (grub_mul (glyph_id->ncomb, 2, &render_max_comb_glyphs))
+    render_max_comb_glyphs = 0;
+  if (render_max_comb_glyphs > 0 && render_max_comb_glyphs < 8)
     render_max_comb_glyphs = 8;
   grub_free (render_combining_glyphs);
-  render_combining_glyphs = grub_malloc (render_max_comb_glyphs
-					 * sizeof (render_combining_glyphs[0]));
+  render_combining_glyphs = (render_max_comb_glyphs > 0) ?
+    grub_calloc (render_max_comb_glyphs, sizeof (render_combining_glyphs[0])) : NULL;
   if (!render_combining_glyphs)
-    grub_errno = 0;
+    {
+      render_max_comb_glyphs = 0;
+      grub_errno = GRUB_ERR_NONE;
+    }
 }
 
 int
@@ -1504,6 +1528,7 @@ grub_font_construct_glyph (grub_font_t hinted_font,
   struct grub_video_signed_rect bounds;
   static struct grub_font_glyph *glyph = 0;
   static grub_size_t max_glyph_size = 0;
+  grub_size_t cur_glyph_size;
 
   ensure_comb_space (glyph_id);
 
@@ -1520,29 +1545,33 @@ grub_font_construct_glyph (grub_font_t hinted_font,
   if (!glyph_id->ncomb && !glyph_id->attributes)
     return main_glyph;
 
-  if (max_glyph_size < sizeof (*glyph) + (bounds.width * bounds.height + GRUB_CHAR_BIT - 1) / GRUB_CHAR_BIT)
+  if (grub_video_bitmap_calc_1bpp_bufsz (bounds.width, bounds.height, &cur_glyph_size) ||
+      grub_add (sizeof (*glyph), cur_glyph_size, &cur_glyph_size))
+    return main_glyph;
+
+  if (max_glyph_size < cur_glyph_size)
     {
       grub_free (glyph);
-      max_glyph_size = (sizeof (*glyph) + (bounds.width * bounds.height + GRUB_CHAR_BIT - 1) / GRUB_CHAR_BIT) * 2;
-      if (max_glyph_size < 8)
-	max_glyph_size = 8;
-      glyph = grub_malloc (max_glyph_size);
+      if (grub_mul (cur_glyph_size, 2, &max_glyph_size))
+       max_glyph_size = 0;
+      glyph = max_glyph_size > 0 ? grub_malloc (max_glyph_size) : NULL;
     }
   if (!glyph)
     {
+      max_glyph_size = 0;
       grub_errno = GRUB_ERR_NONE;
       return main_glyph;
     }
 
-  grub_memset (glyph, 0, sizeof (*glyph)
-	       + (bounds.width * bounds.height
-		  + GRUB_CHAR_BIT - 1) / GRUB_CHAR_BIT);
+  grub_memset (glyph, 0, cur_glyph_size);
 
   glyph->font = main_glyph->font;
-  glyph->width = bounds.width;
-  glyph->height = bounds.height;
-  glyph->offset_x = bounds.x;
-  glyph->offset_y = bounds.y;
+  if (bounds.width == 0 || bounds.height == 0 ||
+      grub_cast (bounds.width, &glyph->width) ||
+      grub_cast (bounds.height, &glyph->height) ||
+      grub_cast (bounds.x, &glyph->offset_x) ||
+      grub_cast (bounds.y, &glyph->offset_y))
+    return main_glyph;
 
   if (glyph_id->attributes & GRUB_UNICODE_GLYPH_ATTRIBUTE_MIRROR)
     grub_font_blit_glyph_mirror (glyph, main_glyph,
diff --git a/grub-core/normal/charset.c b/grub-core/normal/charset.c
index d89c0da..dfc1572 100644
--- a/grub-core/normal/charset.c
+++ b/grub-core/normal/charset.c
@@ -470,6 +470,9 @@ grub_unicode_aglomerate_comb (const grub_uint32_t *in, grub_size_t inlen,
 	  if (!haveout)
 	    continue;
 
+	  if (out->ncomb == GRUB_UNICODE_NCOMB_MAX)
+	    continue;
+
 	  if (comb_type == GRUB_UNICODE_COMB_MC
 	      || comb_type == GRUB_UNICODE_COMB_ME
 	      || comb_type == GRUB_UNICODE_COMB_MN)
diff --git a/grub-core/video/fb/fbutil.c b/grub-core/video/fb/fbutil.c
index b98bb51..25ef39f 100644
--- a/grub-core/video/fb/fbutil.c
+++ b/grub-core/video/fb/fbutil.c
@@ -67,7 +67,7 @@ get_pixel (struct grub_video_fbblit_info *source,
     case 1:
       if (source->mode_info->blit_format == GRUB_VIDEO_BLIT_FORMAT_1BIT_PACKED)
         {
-          int bit_index = y * source->mode_info->width + x;
+          grub_uint64_t bit_index = (grub_uint64_t) y * source->mode_info->width + x;
           grub_uint8_t *ptr = source->data + bit_index / 8;
           int bit_pos = 7 - bit_index % 8;
           color = (*ptr >> bit_pos) & 0x01;
@@ -138,7 +138,7 @@ set_pixel (struct grub_video_fbblit_info *source,
     case 1:
       if (source->mode_info->blit_format == GRUB_VIDEO_BLIT_FORMAT_1BIT_PACKED)
         {
-          int bit_index = y * source->mode_info->width + x;
+          grub_uint64_t bit_index = (grub_uint64_t) y * source->mode_info->width + x;
           grub_uint8_t *ptr = source->data + bit_index / 8;
           int bit_pos = 7 - bit_index % 8;
           *ptr = (*ptr & ~(1 << bit_pos)) | ((color & 0x01) << bit_pos);
diff --git a/include/grub/bitmap.h b/include/grub/bitmap.h
index 5728f8c..6682ed2 100644
--- a/include/grub/bitmap.h
+++ b/include/grub/bitmap.h
@@ -23,6 +23,7 @@
 #include <grub/symbol.h>
 #include <grub/types.h>
 #include <grub/video.h>
+#include <grub/safemath.h>
 
 struct grub_video_bitmap
 {
@@ -78,6 +79,23 @@ grub_video_bitmap_get_height (struct grub_video_bitmap *bitmap)
 
   return bitmap->mode_info.height;
 }
+/*
+ * Calculate and store the size of data buffer of 1bit bitmap in result.
+ * Equivalent to "*result = (width * height + 7) / 8" if no overflow occurs.
+ * Return true when overflow occurs or false if there is no overflow.
+ * This function is intentionally implemented as a macro instead of
+ * an inline function. Although a bit awkward, it preserves data types for
+ * safemath macros and reduces macro side effects as much as possible.
+ *
+ * XXX: Will report false overflow if width * height > UINT64_MAX.
+ */
+#define grub_video_bitmap_calc_1bpp_bufsz(width, height, result) \
+({ \
+  grub_uint64_t _bitmap_pixels; \
+  grub_mul ((width), (height), &_bitmap_pixels) ? 1 : \
+    grub_cast (_bitmap_pixels / GRUB_CHAR_BIT + !!(_bitmap_pixels % GRUB_CHAR_BIT), (result)); \
+})
+
 
 void EXPORT_FUNC (grub_video_bitmap_get_mode_info) (struct grub_video_bitmap *bitmap,
 						    struct grub_video_mode_info *mode_info);
diff --git a/include/grub/fbutil.h b/include/grub/fbutil.h
index 4205eb9..78a1ab3 100644
--- a/include/grub/fbutil.h
+++ b/include/grub/fbutil.h
@@ -31,14 +31,19 @@ struct grub_video_fbblit_info
   grub_uint8_t *data;
 };
 
-/* Don't use for 1-bit bitmaps, addressing needs to be done at the bit level
-   and it doesn't make sense, in general, to ask for a pointer
-   to a particular pixel's data.  */
+/*
+ * Don't use for 1-bit bitmaps, addressing needs to be done at the bit level
+ * and it doesn't make sense, in general, to ask for a pointer
+ * to a particular pixel's data.
+ *
+ * This function assumes that bounds checking has been done in previous phase
+ * and they are opted out in here.
+ */
 static inline void *
 grub_video_fb_get_video_ptr (struct grub_video_fbblit_info *source,
               unsigned int x, unsigned int y)
 {
-  return source->data + y * source->mode_info->pitch + x * source->mode_info->bytes_per_pixel;
+  return source->data + (grub_addr_t) y * source->mode_info->pitch + (grub_addr_t) x * source->mode_info->bytes_per_pixel;
 }
 
 /* Advance pointer by VAL bytes. If there is no unaligned access available,
diff --git a/include/grub/safemath.h b/include/grub/safemath.h
index 1ccac27..bfc05da 100644
--- a/include/grub/safemath.h
+++ b/include/grub/safemath.h
@@ -30,6 +30,8 @@
 #define grub_sub(a, b, res)	__builtin_sub_overflow(a, b, res)
 #define grub_mul(a, b, res)	__builtin_mul_overflow(a, b, res)
 
+#define grub_cast(a, res)      grub_add ((a), 0, (res))
+
 #else
 /*
  * Copyright 2020 Rasmus Villemoes
@@ -149,6 +151,8 @@
 			__signed_mul_overflow(a, b, d),		\
 			__unsigned_mul_overflow(a, b, d))
 
+#define grub_cast(a, res)      grub_add ((a), 0, (res))
+
 #endif
 
 #endif /* GRUB_SAFEMATH_H */
diff --git a/include/grub/unicode.h b/include/grub/unicode.h
index 4de986a..c4f6fca 100644
--- a/include/grub/unicode.h
+++ b/include/grub/unicode.h
@@ -147,7 +147,9 @@ struct grub_unicode_glyph
   grub_uint8_t bidi_level:6; /* minimum: 6 */
   enum grub_bidi_type bidi_type:5; /* minimum: :5 */
 
+#define GRUB_UNICODE_NCOMB_MAX ((1 << 8) - 1)
   unsigned ncomb:8;
+
   /* Hint by unicode subsystem how wide this character usually is.
      Real width is determined by font. Set only in UTF-8 stream.  */
   int estimated_width:8;
-- 

