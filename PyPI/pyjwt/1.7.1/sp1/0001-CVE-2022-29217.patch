From bb6144ecff19dcf0088cbf683d43da5ee3efb380 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Sun, 21 May 2023 15:05:05 +0300
Subject: [PATCH 1/1] Seal Security Hotfix for pyjwt 1.7.1

This patch fixes:
  CVE-2022-29217

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/jpadilla/pyjwt/tree/1.7.1
---
 jwt/algorithms.py | 11 ++-------
 jwt/utils.py      | 61 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 63 insertions(+), 9 deletions(-)

diff --git a/jwt/algorithms.py b/jwt/algorithms.py
index 1343688..9376353 100644
--- a/jwt/algorithms.py
+++ b/jwt/algorithms.py
@@ -7,7 +7,7 @@ from .compat import constant_time_compare, string_types
 from .exceptions import InvalidKeyError
 from .utils import (
     base64url_decode, base64url_encode, der_to_raw_signature,
-    force_bytes, force_unicode, from_base64url_uint, raw_to_der_signature,
+    force_bytes, force_unicode, from_base64url_uint, is_pem_format, is_ssh_key, raw_to_der_signature,
     to_base64url_uint
 )
 
@@ -139,14 +139,7 @@ class HMACAlgorithm(Algorithm):
     def prepare_key(self, key):
         key = force_bytes(key)
 
-        invalid_strings = [
-            b'-----BEGIN PUBLIC KEY-----',
-            b'-----BEGIN CERTIFICATE-----',
-            b'-----BEGIN RSA PUBLIC KEY-----',
-            b'ssh-rsa'
-        ]
-
-        if any([string_value in key for string_value in invalid_strings]):
+        if is_pem_format(key) or is_ssh_key(key):
             raise InvalidKeyError(
                 'The specified key is an asymmetric key or x509 certificate and'
                 ' should not be used as an HMAC secret.')
diff --git a/jwt/utils.py b/jwt/utils.py
index b33c7a2..c2f7c81 100644
--- a/jwt/utils.py
+++ b/jwt/utils.py
@@ -1,5 +1,6 @@
 import base64
 import binascii
+import re
 import struct
 
 from .compat import binary_type, bytes_from_int, text_type
@@ -111,3 +112,63 @@ def raw_to_der_signature(raw_sig, curve):
     s = bytes_to_number(raw_sig[num_bytes:])
 
     return encode_dss_signature(r, s)
+
+
+# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252
+_PEMS = {
+    b"CERTIFICATE",
+    b"TRUSTED CERTIFICATE",
+    b"PRIVATE KEY",
+    b"PUBLIC KEY",
+    b"ENCRYPTED PRIVATE KEY",
+    b"OPENSSH PRIVATE KEY",
+    b"DSA PRIVATE KEY",
+    b"RSA PRIVATE KEY",
+    b"RSA PUBLIC KEY",
+    b"EC PRIVATE KEY",
+    b"DH PARAMETERS",
+    b"NEW CERTIFICATE REQUEST",
+    b"CERTIFICATE REQUEST",
+    b"SSH2 PUBLIC KEY",
+    b"SSH2 ENCRYPTED PRIVATE KEY",
+    b"X509 CRL",
+}
+
+_PEM_RE = re.compile(
+    b"----[- ]BEGIN ("
+    + b"|".join(_PEMS)
+    + b""")[- ]----\r?
+.+?\r?
+----[- ]END \\1[- ]----\r?\n?""",
+    re.DOTALL,
+)
+
+
+def is_pem_format(key: bytes) -> bool:
+    return bool(_PEM_RE.search(key))
+
+
+# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46
+_CERT_SUFFIX = b"-cert-v01@openssh.com"
+_SSH_PUBKEY_RC = re.compile(br"\A(\S+)[ \t]+(\S+)")
+_SSH_KEY_FORMATS = [
+    b"ssh-ed25519",
+    b"ssh-rsa",
+    b"ssh-dss",
+    b"ecdsa-sha2-nistp256",
+    b"ecdsa-sha2-nistp384",
+    b"ecdsa-sha2-nistp521",
+]
+
+
+def is_ssh_key(key: bytes) -> bool:
+    if any(string_value in key for string_value in _SSH_KEY_FORMATS):
+        return True
+
+    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)
+    if ssh_pubkey_match:
+        key_type = ssh_pubkey_match.group(1)
+        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:
+            return True
+
+    return False
-- 
2.37.1 (Apple Git-137.1)

