From cf77a7fc56d5327d9be51e0e25c5b581f1cd52a7 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Thu, 27 Jul 2023 11:49:51 +0300
Subject: [PATCH 1/1] Seal Security Hotfix for xml2js 0.4.19

This patch fixes:
  CVE-2023-0842

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/Leonidas-from-XIV/node-xml2js/tree/0.4.19
---
 lib/parser.js     | 24 +++++++++++++++++-------
 src/parser.coffee | 22 ++++++++++++++++------
 2 files changed, 33 insertions(+), 13 deletions(-)

diff --git a/lib/parser.js b/lib/parser.js
index 59f4d54..10e08a1 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -1,7 +1,7 @@
 // Generated by CoffeeScript 1.12.7
 (function() {
   "use strict";
-  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
+  var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate,
     bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
     extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
     hasProp = {}.hasOwnProperty;
@@ -31,6 +31,16 @@
     return item;
   };
 
+  defineProperty = function(obj, key, value) {
+    var descriptor;
+    descriptor = Object.create(null);
+    descriptor.value = value;
+    descriptor.writable = true;
+    descriptor.enumerable = true;
+    descriptor.configurable = true;
+    return Object.defineProperty(obj, key, descriptor);
+  };
+
   exports.Parser = (function(superClass) {
     extend(Parser, superClass);
 
@@ -94,13 +104,13 @@
     Parser.prototype.assignOrPush = function(obj, key, newValue) {
       if (!(key in obj)) {
         if (!this.options.explicitArray) {
-          return obj[key] = newValue;
+          return defineProperty(obj, key, newValue);
         } else {
-          return obj[key] = [newValue];
+          return defineProperty(obj, key, [newValue]);
         }
       } else {
         if (!(obj[key] instanceof Array)) {
-          obj[key] = [obj[key]];
+          defineProperty(obj, key, [obj[key]]);
         }
         return obj[key].push(newValue);
       }
@@ -155,7 +165,7 @@
               if (_this.options.mergeAttrs) {
                 _this.assignOrPush(obj, processedKey, newValue);
               } else {
-                obj[attrkey][processedKey] = newValue;
+                defineProperty(obj[attrkey], processedKey, newValue);
               }
             }
           }
@@ -240,7 +250,7 @@
               objClone = {};
               for (key in obj) {
                 if (!hasProp.call(obj, key)) continue;
-                objClone[key] = obj[key];
+                defineProperty(objClone, key, obj[key]);
               }
               s[_this.options.childkey].push(objClone);
               delete obj["#name"];
@@ -255,7 +265,7 @@
             if (_this.options.explicitRoot) {
               old = obj;
               obj = {};
-              obj[nodeName] = old;
+              defineProperty(obj, nodeName, old);
             }
             _this.resultObject = obj;
             _this.saxParser.ended = true;
diff --git a/src/parser.coffee b/src/parser.coffee
index 3796796..2335cc8 100644
--- a/src/parser.coffee
+++ b/src/parser.coffee
@@ -15,6 +15,15 @@ processItem = (processors, item, key) ->
   item = process(item, key) for process in processors
   return item
 
+defineProperty = (obj, key, value) ->
+  # make sure the descriptor hasn't been prototype polluted
+  descriptor = Object.create null
+  descriptor.value = value
+  descriptor.writable = true
+  descriptor.enumerable = true
+  descriptor.configurable = true
+  Object.defineProperty obj, key, descriptor
+
 class exports.Parser extends events.EventEmitter
   constructor: (opts) ->
     # if this was called without 'new', create an instance with new and return
@@ -54,11 +63,12 @@ class exports.Parser extends events
   assignOrPush: (obj, key, newValue) =>
     if key not of obj
       if not @options.explicitArray
-        obj[key] = newValue
+        defineProperty obj, key, newValue
       else
-        obj[key] = [newValue]
+        defineProperty obj, key, [newValue]
     else
-      obj[key] = [obj[key]] if not (obj[key] instanceof Array)
+      unless obj[key] instanceof Array
+        defineProperty obj, key, [obj[key]]
       obj[key].push newValue
 
   reset: =>
@@ -113,7 +123,7 @@ class exports.Parser extends events
           if @options.mergeAttrs
             @assignOrPush obj, processedKey, newValue
           else
-            obj[attrkey][processedKey] = newValue
+            defineProperty obj[attrkey], processedKey, newValue
 
       # need a place to store the node name
       obj["#name"] = if @options.tagNameProcessors then processItem(@options.tagNameProcessors, node.name) else node.name
@@ -180,7 +190,7 @@ class exports.Parser extends events
           # push a clone so that the node in the children array can receive the #name property while the original obj can do without it
           objClone = {}
           for own key of obj
-            objClone[key] = obj[key]
+            defineProperty objClone, key, obj[key]
           s[@options.childkey].push objClone
           delete obj["#name"]
           # re-check whether we can collapse the node now to just the charkey value
@@ -196,7 +206,7 @@ class exports.Parser extends events
           # avoid circular references
           old = obj
           obj = {}
-          obj[nodeName] = old
+          defineProperty obj, nodeName, old
 
         @resultObject = obj
         # parsing has ended, mark that so we won't throw exceptions from
-- 


