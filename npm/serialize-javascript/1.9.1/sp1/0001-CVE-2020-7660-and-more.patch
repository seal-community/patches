From f62a2c96f26b50e98709a09e09c48b8edf43b164 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Sun, 4 Jun 2023 12:06:56 +0300
Subject: [PATCH 1/1] Seal Security Hotfix for serialize-javascript 1.9.1

This patch fixes:
  CVE-2019-16769
  CVE-2020-7660

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/yahoo/serialize-javascript/tree/v1.9.1
---
 index.js               | 27 +++++++++++++++++----
 package-lock.json      | 13 ++++++++++
 package.json           |  3 +++
 test/unit/serialize.js | 54 +++++++++++++++++++++++++++++++++---------
 4 files changed, 82 insertions(+), 15 deletions(-)

diff --git a/index.js b/index.js
index b10a500..6b82b1d 100644
--- a/index.js
+++ b/index.js
@@ -6,9 +6,12 @@ See the accompanying LICENSE file for terms.
 
 'use strict';
 
+var randomBytes = require('randombytes');
+
 // Generate an internal UID to make the regexp pattern harder to guess.
-var UID                 = Math.floor(Math.random() * 0x10000000000).toString(16);
-var PLACE_HOLDER_REGEXP = new RegExp('"@__(F|R|D|M|S)-' + UID + '-(\\d+)__@"', 'g');
+var UID_LENGTH          = 16;
+var UID                 = generateUID();
+var PLACE_HOLDER_REGEXP = new RegExp('(\\\\)?"@__(F|R|D|M|S|U|I)-' + UID + '-(\\d+)__@"', 'g');
 
 var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
 var IS_PURE_FUNCTION = /function.*?\(/;
@@ -31,6 +34,15 @@ function escapeUnsafeChars(unsafeChar) {
     return ESCAPED_CHARS[unsafeChar];
 }
 
+function generateUID() {
+    var bytes = randomBytes(UID_LENGTH);
+    var result = '';
+    for(var i=0; i<UID_LENGTH; ++i) {
+        result += bytes[i].toString(16);
+    }
+    return result;
+}
+
 module.exports = function serialize(obj, options) {
     options || (options = {});
 
@@ -149,13 +161,20 @@ module.exports = function serialize(obj, options) {
     // Replaces all occurrences of function, regexp, date, map and set placeholders in the
     // JSON string with their string representations. If the original value can
     // not be found, then `undefined` is used.
-    return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {
+    return str.replace(PLACE_HOLDER_REGEXP, function (match, backSlash, type, valueIndex) {
+        // The placeholder may not be preceded by a backslash. This is to prevent
+        // replacing things like `"a\"@__R-<UID>-0__@"` and thus outputting
+        // invalid JS.
+        if (backSlash) {
+            return match;
+        }
+
         if (type === 'D') {
             return "new Date(\"" + dates[valueIndex].toISOString() + "\")";
         }
 
         if (type === 'R') {
-            return regexps[valueIndex].toString();
+            return "new RegExp(\"" + regexps[valueIndex].source + "\", \"" + regexps[valueIndex].flags + "\")";
         }
 
         if (type === 'M') {
diff --git a/package-lock.json b/package-lock.json
index 60c2eaf..f7e1372 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -963,6 +963,14 @@
         "once": "^1.3.1"
       }
     },
+    "randombytes": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
+      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
+      "requires": {
+        "safe-buffer": "^5.1.0"
+      }
+    },
     "require-directory": {
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
@@ -981,6 +989,11 @@
       "integrity": "sha1-IDEU2CrSxe2ejgQRs5ModeiJ6Xs=",
       "dev": true
     },
+    "safe-buffer": {
+      "version": "5.2.1",
+      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
+      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
+    },
     "semver": {
       "version": "5.7.1",
       "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
diff --git a/package.json b/package.json
index 38de0ef..0b3974a 100644
--- a/package.json
+++ b/package.json
@@ -29,5 +29,8 @@
     "chai": "^4.1.0",
     "istanbul": "^0.4.5",
     "mocha": "^6.2.0"
+  },
+  "dependencies": {
+    "randombytes": "^2.1.0"
   }
 }
diff --git a/test/unit/serialize.js b/test/unit/serialize.js
index a350449..af505bf 100644
--- a/test/unit/serialize.js
+++ b/test/unit/serialize.js
@@ -1,9 +1,23 @@
 /* global describe, it, beforeEach */
 'use strict';
 
+// temporarily monkeypatch `crypto.randomBytes` so we'll have a
+// predictable UID for our tests
+var crypto = require('crypto');
+var oldRandom = crypto.randomBytes;
+crypto.randomBytes = function(len, cb) {
+    var buf = Buffer.alloc(len);
+    buf.fill(0x00);
+    if (cb)
+        cb(null, buf);
+    return buf;
+};
+
 var serialize = require('../../'),
     expect    = require('chai').expect;
 
+crypto.randomBytes = oldRandom;
+
 describe('serialize( obj )', function () {
     it('should be a function', function () {
         expect(serialize).to.be.a('function');
@@ -244,7 +258,7 @@ describe('serialize( obj )', function () {
     describe('regexps', function () {
         it('should serialize constructed regexps', function () {
             var re = new RegExp('asdf');
-            expect(serialize(re)).to.be.a('string').equal('/asdf/');
+            expect(serialize(re)).to.be.a('string').equal('new RegExp("asdf", "")');
         });
 
         it('should deserialize constructed regexps', function () {
@@ -255,7 +269,7 @@ describe('serialize( obj )', function () {
 
         it('should serialize literal regexps', function () {
             var re = /asdf/;
-            expect(serialize(re)).to.be.a('string').equal('/asdf/');
+            expect(serialize(re)).to.be.a('string').equal('new RegExp("asdf", "")');
         });
 
         it('should deserialize literal regexps', function () {
@@ -266,7 +280,7 @@ describe('serialize( obj )', function () {
 
         it('should serialize regexps with flags', function () {
             var re = /^asdf$/gi;
-            expect(serialize(re)).to.equal('/^asdf$/gi');
+            expect(serialize(re)).to.equal('new RegExp("^asdf$", "gi")');
         });
 
         it('should deserialize regexps with flags', function () {
@@ -278,17 +292,22 @@ describe('serialize( obj )', function () {
         });
 
         it('should serialize regexps with escaped chars', function () {
-            expect(serialize(/\..*/)).to.equal('/\\..*/');
-            expect(serialize(new RegExp('\\..*'))).to.equal('/\\..*/');
+            expect(serialize(/\..*/)).to.equal('new RegExp("\\..*", "")');
+            expect(serialize(new RegExp('\\..*'))).to.equal('new RegExp("\\..*", "")');
         });
 
         it('should deserialize regexps with escaped chars', function () {
             var re = eval(serialize(/\..*/));
             expect(re).to.be.a('RegExp');
-            expect(re.source).to.equal('\\..*');
+            expect(re.source).to.equal('..*');
             re = eval(serialize(new RegExp('\\..*')));
             expect(re).to.be.a('RegExp');
-            expect(re.source).to.equal('\\..*');
+            expect(re.source).to.equal('..*');
+        });
+
+        it('should serialize dangerous regexps', function () {
+            var re = /[</script><script>alert('xss')//]/
+            expect(serialize(re)).to.be.a('string').equal('new RegExp("[<\\/script><script>alert(\'xss\')\\/\\/]", "")');
         });
     });
 
@@ -325,8 +344,8 @@ describe('serialize( obj )', function () {
                 ['a', 123],
                 [regexKey, 456]
             ]);
-            expect(serialize(m)).to.be.a('string').equal('new Map([["a",123],[/.*/,456]])');
-            expect(serialize({t: [m]})).to.be.a('string').equal('{"t":[new Map([["a",123],[/.*/,456]])]}');
+            expect(serialize(m)).to.be.a('string').equal('new Map([["a",123],[new RegExp(".*", ""),456]])');
+            expect(serialize({t: [m]})).to.be.a('string').equal('{"t":[new Map([["a",123],[new RegExp(".*", ""),456]])]}');
         });
 
         it('should deserialize a map', function () {
@@ -347,8 +366,8 @@ describe('serialize( obj )', function () {
                 123,
                 regex
             ]);
-            expect(serialize(m)).to.be.a('string').equal('new Set(["a",123,/.*/])');
-            expect(serialize({t: [m]})).to.be.a('string').equal('{"t":[new Set(["a",123,/.*/])]}');
+            expect(serialize(m)).to.be.a('string').equal('new Set(["a",123,new RegExp(".*", "")])');
+            expect(serialize({t: [m]})).to.be.a('string').equal('{"t":[new Set(["a",123,new RegExp(".*", "")])]}');
         });
 
         it('should deserialize a set', function () {
@@ -432,4 +451,17 @@ describe('serialize( obj )', function () {
             expect(serialize([1], 2)).to.equal('[\n  1\n]');
         });
     });
+
+    describe('placeholders', function() {
+        it('should not be replaced within string literals', function () {
+            // Since we made the UID deterministic this should always be the placeholder
+            var fakePlaceholder = '"@__R-0000000000000000-0__@';
+            var serialized = serialize({bar: /1/i, foo: fakePlaceholder}, {uid: 'foo'});
+            var obj = eval('(' + serialized + ')');
+            expect(obj).to.be.a('Object');
+            expect(obj.foo).to.be.a('String');
+            expect(obj.foo).to.equal(fakePlaceholder);
+        });
+    });
+
 });
-- 
2.39.2 (Apple Git-143)

