From 7462ae11689744a2b1964f23356bce4f843a7659 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Sun, 24 Sep 2023 11:42:33 +0300
Subject: [PATCH 1/1] Seal Security Hotfix for bson 1.0.9

This patch fixes:
  CVE-2020-7610
  CVE-2019-2391

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/mongodb/js-bson/tree/v1.0.9
---
 browser_build/bson.js         |  6 ++++++
 lib/bson/parser/serializer.js |  6 ++++++
 test/node/bson_test.js        | 21 +++++++++++++++++++++
 3 files changed, 33 insertions(+)

diff --git a/browser_build/bson.js b/browser_build/bson.js
index a02bf14..2ccd38a 100644
--- a/browser_build/bson.js
+++ b/browser_build/bson.js
@@ -17074,6 +17074,8 @@ return /******/ (function(modules) { // webpackBootstrap
 	        index = serializeInt32(buffer, key, value, index, true);
 	      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
 	        index = serializeMinMax(buffer, key, value, index, true);
+	      } else if (typeof value['_bsontype'] !== 'undefined') {
+	        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
 	      }
 	    }
 	  } else if (object instanceof Map) {
@@ -17152,6 +17154,8 @@ return /******/ (function(modules) { // webpackBootstrap
 	        index = serializeInt32(buffer, key, value, index);
 	      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
 	        index = serializeMinMax(buffer, key, value, index);
+	      } else if (typeof value['_bsontype'] !== 'undefined') {
+	        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
 	      }
 	    }
 	  } else {
@@ -17233,6 +17237,8 @@ return /******/ (function(modules) { // webpackBootstrap
 	        index = serializeInt32(buffer, key, value, index);
 	      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
 	        index = serializeMinMax(buffer, key, value, index);
+	      } else if (typeof value['_bsontype'] !== 'undefined') {
+	        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
 	      }
 	    }
 	  }
diff --git a/lib/bson/parser/serializer.js b/lib/bson/parser/serializer.js
index 12c6b2d..c74aace 100644
--- a/lib/bson/parser/serializer.js
+++ b/lib/bson/parser/serializer.js
@@ -777,6 +777,8 @@ var serializeInto = function serializeInto(
         index = serializeInt32(buffer, key, value, index, true);
       } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
         index = serializeMinMax(buffer, key, value, index, true);
+      } else if (typeof value['_bsontype'] !== 'undefined') {
+        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
       }
     }
   } else if (object instanceof Map) {
@@ -875,6 +877,8 @@ var serializeInto = function serializeInto(
         index = serializeInt32(buffer, key, value, index);
       } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
         index = serializeMinMax(buffer, key, value, index);
+      } else if (typeof value['_bsontype'] !== 'undefined') {
+        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
       }
     }
   } else {
@@ -977,6 +981,8 @@ var serializeInto = function serializeInto(
         index = serializeInt32(buffer, key, value, index);
       } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
         index = serializeMinMax(buffer, key, value, index);
+      } else if (typeof value['_bsontype'] !== 'undefined') {
+        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
       }
     }
   }
diff --git a/test/node/bson_test.js b/test/node/bson_test.js
index a74f86b..6f3b3dd 100644
--- a/test/node/bson_test.js
+++ b/test/node/bson_test.js
@@ -21,6 +21,7 @@ var Buffer = require('buffer').Buffer,
   vm = require('vm');
 
 var createBSON = require('../utils');
+var M = require('../../lib/bson/map');
 
 // for tests
 BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
@@ -2346,3 +2347,23 @@ exports['Should return boolean for ObjectID equality check'] = function(test) {
   test.equal(false, id.equals(undefined));
   test.done();
 };
+
+exports['should throw if invalid BSON types are input to BSON serializer'] = function(test) {
+  var oid = new ObjectId('111111111111111111111111');
+  var badBsonType = new ObjectId('111111111111111111111111');
+  badBsonType._bsontype = 'bogus';
+  var badDoc = { bad: badBsonType };
+  var badArray = [oid, badDoc];
+  var badMap = new M([['a', badBsonType], ['b', badDoc], ['c', badArray]]);
+  var BSON = createBSON();
+  test.throws(function() {
+    BSON.serialize(badDoc);
+  });
+  test.throws(function() {
+    BSON.serialize(badArray);
+  });
+  test.throws(function() {
+    BSON.serialize(badMap);
+  });
+  test.done();
+}
-- 

