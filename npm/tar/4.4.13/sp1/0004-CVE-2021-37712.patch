From 582dbc262d852f0aa2646e6b7ff2d1556f2035e4 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Mon, 29 Jan 2024 16:23:13 +0200
Subject: [PATCH 4/5] Seal Security Hotfix for tar 4.4.13

This patch fixes:
  CVE-2021-37712

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/isaacs/node-tar/tree/v4.4.13
---
 lib/strip-trailing-slashes.js  |  24 +++++
 lib/unpack.js                  |  64 ++++++++++----
 test/strip-trailing-slashes.js |  14 +++
 test/unpack.js                 | 155 ++++++++++++++++++++++++++++++++-
 test/utils/caller.js           |  29 ++++++
 test/utils/require-inject.js   |  97 +++++++++++++++++++++
 6 files changed, 367 insertions(+), 16 deletions(-)
 create mode 100644 lib/strip-trailing-slashes.js
 create mode 100644 test/strip-trailing-slashes.js
 create mode 100644 test/utils/caller.js
 create mode 100644 test/utils/require-inject.js

diff --git a/lib/strip-trailing-slashes.js b/lib/strip-trailing-slashes.js
new file mode 100644
index 0000000..f702ed5
--- /dev/null
+++ b/lib/strip-trailing-slashes.js
@@ -0,0 +1,24 @@
+// this is the only approach that was significantly faster than using
+// str.replace(/\/+$/, '') for strings ending with a lot of / chars and
+// containing multiple / chars.
+const batchStrings = [
+  '/'.repeat(1024),
+  '/'.repeat(512),
+  '/'.repeat(256),
+  '/'.repeat(128),
+  '/'.repeat(64),
+  '/'.repeat(32),
+  '/'.repeat(16),
+  '/'.repeat(8),
+  '/'.repeat(4),
+  '/'.repeat(2),
+  '/',
+]
+
+module.exports = str => {
+  for (const s of batchStrings) {
+    while (str.length >= s.length && str.slice(-1 * s.length) === s)
+      str = str.slice(0, -1 * s.length)
+  }
+  return str
+}
diff --git a/lib/unpack.js b/lib/unpack.js
index 4e46bd2..9c65d91 100644
--- a/lib/unpack.js
+++ b/lib/unpack.js
@@ -11,9 +11,11 @@ const mkdirSync = mkdir.sync
 const wc = require('./winchars.js')
 const stripAbsolutePath = require('./strip-absolute-path.js')
 const normPath = require('./normalize-windows-path.js')
+const stripSlash = require('./strip-trailing-slashes.js')
 
 const ONENTRY = Symbol('onEntry')
 const CHECKFS = Symbol('checkFs')
+const PRUNECACHE = Symbol('pruneCache')
 const ISREUSABLE = Symbol('isReusable')
 const MAKEFS = Symbol('makeFs')
 const FILE = Symbol('file')
@@ -36,6 +38,8 @@ const DOCHOWN = Symbol('doChown')
 const UID = Symbol('uid')
 const GID = Symbol('gid')
 const crypto = require('crypto')
+const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform
+const isWindows = platform === 'win32'
 
 // Unlinks on Windows are not atomic.
 //
@@ -54,7 +58,7 @@ const crypto = require('crypto')
 // See: https://github.com/npm/node-tar/issues/183
 /* istanbul ignore next */
 const unlinkFile = (path, cb) => {
-  if (process.platform !== 'win32')
+  if (!isWindows)
     return fs.unlink(path, cb)
 
   const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
@@ -67,7 +71,7 @@ const unlinkFile = (path, cb) => {
 
 /* istanbul ignore next */
 const unlinkFileSync = path => {
-  if (process.platform !== 'win32')
+  if (!isWindows)
     return fs.unlinkSync(path)
 
   const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
@@ -81,18 +85,33 @@ const uint32 = (a, b, c) =>
   : b === b >>> 0 ? b
   : c
 
+// clear the cache if it's a case-insensitive unicode-squashing match.
+// we can't know if the current file system is case-sensitive or supports
+// unicode fully, so we check for similarity on the maximally compatible
+// representation.  Err on the side of pruning, since all it's doing is
+// preventing lstats, and it's not the end of the world if we get a false
+// positive.
+// Note that on windows, we always drop the entire cache whenever a
+// symbolic link is encountered, because 8.3 filenames are impossible
+// to reason about, and collisions are hazards rather than just failures.
+const cacheKeyNormalize = path => stripSlash(normPath(path))
+  .normalize('NFKD')
+  .toLowerCase()
 
 const pruneCache = (cache, abs) => {
-  // clear the cache if it's a case-insensitive match, since we can't
-  // know if the current file system is case-sensitive or not.
-  abs = normPath(abs).toLowerCase()
+  abs = cacheKeyNormalize(abs)
   for (const path of cache.keys()) {
-    const plower = path.toLowerCase()
-    if (plower === abs || plower.toLowerCase().indexOf(abs + '/') === 0)
+    const pnorm = cacheKeyNormalize(path)
+    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)
       cache.delete(path)
   }
 }
 
+const dropCache = cache => {
+  for (const key of cache.keys())
+    cache.delete(key)
+}
+
 class Unpack extends Parser {
   constructor (opt) {
     if (!opt)
@@ -147,7 +166,7 @@ class Unpack extends Parser {
     this.forceChown = opt.forceChown === true
 
     // turn ><?| in filenames into 0xf000-higher encoded forms
-    this.win32 = !!opt.win32 || process.platform === 'win32'
+    this.win32 = !!opt.win32 || isWindows
 
     // do not unpack over files that are newer than what's in the archive
     this.newer = !!opt.newer
@@ -422,7 +441,24 @@ class Unpack extends Parser {
       !this.unlink &&
       st.isFile() &&
       st.nlink <= 1 &&
-      process.platform !== 'win32'
+      isWindows
+  }
+
+  [PRUNECACHE] (entry) {
+    // if we are not creating a directory, and the path is in the dirCache,
+    // then that means we are about to delete the directory we created
+    // previously, and it is no longer going to be a directory, and neither
+    // is any of its children.
+    // If a symbolic link is encountered on Windows, all bets are off.
+    // There is no reasonable way to sanitize the cache in such a way
+    // we will be able to avoid having filesystem collisions.  If this
+    // happens with a non-symlink entry, it'll just fail to unpack,
+    // but a symlink to a directory, using an 8.3 shortname, can evade
+    // detection and lead to arbitrary writes to anywhere on the system.
+    if (isWindows && entry.type === 'SymbolicLink')
+      dropCache(this.dirCache)
+    else if (entry.type !== 'Directory')
+      pruneCache(this.dirCache, entry.absolute)
   }
 
   // check if a thing is there, and if so, try to clobber it
@@ -432,9 +468,8 @@ class Unpack extends Parser {
     // then that means we are about to delete the directory we created
     // previously, and it is no longer going to be a directory, and neither
     // is any of its children.
-    if (entry.type !== 'Directory') {
-      pruneCache(this.dirCache, entry.absolute)
-    }
+    this[PRUNECACHE](entry)
+    
     this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {
       if (er)
         return this[ONERROR](er, entry)
@@ -496,9 +531,8 @@ class UnpackSync extends Unpack {
   }
 
   [CHECKFS] (entry) {
-    if (entry.type !== 'Directory') {
-      pruneCache(this.dirCache, entry.absolute)
-    }
+    this[PRUNECACHE](entry)
+    
     const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)
     if (er)
       return this[ONERROR](er, entry)
diff --git a/test/strip-trailing-slashes.js b/test/strip-trailing-slashes.js
new file mode 100644
index 0000000..cbb45fc
--- /dev/null
+++ b/test/strip-trailing-slashes.js
@@ -0,0 +1,14 @@
+const t = require('tap')
+const stripTrailingSlashes = require('../lib/strip-trailing-slashes.js')
+
+const cases = {
+  '/': '',
+  '////': '',
+  'c:///a/b/c': 'c:///a/b/c',
+  '\\\\foo\\bar\\baz': '\\\\foo\\bar\\baz',
+  '//foo//bar//baz': '//foo//bar//baz',
+  'c:\\c:\\c:\\c:\\\\d:\\e/f/g': 'c:\\c:\\c:\\c:\\\\d:\\e/f/g',
+}
+
+for (const [input, stripped] of Object.entries(cases))
+  t.strictSame(stripTrailingSlashes(input), stripped, input)
diff --git a/test/unpack.js b/test/unpack.js
index b9539b8..fa2da21 100644
--- a/test/unpack.js
+++ b/test/unpack.js
@@ -21,6 +21,8 @@ const rimraf = require('rimraf')
 const mkdirp = require('mkdirp')
 const mutateFS = require('mutate-fs')
 const eos = require('end-of-stream')
+const requireInject = require('./utils/require-inject.js')
+const isWindows = process.platform === 'win32'
 
 t.teardown(_ => rimraf.sync(unpackdir))
 
@@ -30,6 +32,13 @@ t.test('setup', t => {
   t.end()
 })
 
+const testdir = () => {
+  const testdirpath = path.resolve(unpackdir, Math.random().toString())
+  rimraf.sync(testdirpath)
+  mkdirp.sync(testdirpath)
+  return testdirpath
+}
+
 t.test('basic file unpack tests', t => {
   const basedir = path.resolve(unpackdir, 'basic')
   t.teardown(_ => rimraf.sync(basedir))
@@ -2544,4 +2553,148 @@ t.test('drop entry from dirCache if no longer a directory', t => {
       .end(data)
     check(t, path)
   })
-})
\ No newline at end of file
+})
+
+t.test('dirCache pruning unicode normalized collisions', {
+  skip: isWindows && 'symlinks not fully supported',
+}, t => {
+  const data = makeTar([
+    {
+      type: 'Directory',
+      path: 'foo',
+    },
+    {
+      type: 'File',
+      path: 'foo/bar',
+      size: 1,
+    },
+    'x',
+    {
+      type: 'Directory',
+      // café
+      path: Buffer.from([0x63, 0x61, 0x66, 0xc3, 0xa9]).toString(),
+    },
+    {
+      type: 'SymbolicLink',
+      // cafe with a `
+      path: Buffer.from([0x63, 0x61, 0x66, 0x65, 0xcc, 0x81]).toString(),
+      linkpath: 'foo',
+    },
+    {
+      type: 'File',
+      path: Buffer.from([0x63, 0x61, 0x66, 0xc3, 0xa9]).toString() + '/bar',
+      size: 1,
+    },
+    'y',
+    '',
+    '',
+  ])
+
+  const check = (path, dirCache, t) => {
+    path = path.replace(/\\/g, '/')
+    t.strictSame([...dirCache.entries()], [
+      [path, true],
+      [`${path}/foo`, true],
+    ])
+    t.equal(fs.readFileSync(path + '/foo/bar', 'utf8'), 'x')
+    t.end()
+  }
+
+  t.test('sync', t => {
+    const path = testdir()
+    const dirCache = new Map()
+    new UnpackSync({ cwd: path, dirCache }).end(data)
+    check(path, dirCache, t)
+  })
+  t.test('async', t => {
+    const path = testdir()
+    const dirCache = new Map()
+    new Unpack({ cwd: path, dirCache })
+      .on('close', () => check(path, dirCache, t))
+      .end(data)
+  })
+
+  t.end()
+})
+
+t.test('dircache prune all on windows when symlink encountered', t => {
+  if (process.platform !== 'win32') {
+    process.env.TESTING_TAR_FAKE_PLATFORM = 'win32'
+    t.teardown(() => {
+      delete process.env.TESTING_TAR_FAKE_PLATFORM
+    })
+  }
+  const symlinks = []
+  const Unpack = requireInject('../lib/unpack.js', {
+    fs: {
+      ...fs,
+      symlink: (target, dest, cb) => {
+        symlinks.push(['async', target, dest])
+        process.nextTick(cb)
+      },
+      symlinkSync: (target, dest) => symlinks.push(['sync', target, dest]),
+    },
+  })
+  const UnpackSync = Unpack.Sync
+
+  const data = makeTar([
+    {
+      type: 'Directory',
+      path: 'foo',
+    },
+    {
+      type: 'File',
+      path: 'foo/bar',
+      size: 1,
+    },
+    'x',
+    {
+      type: 'Directory',
+      // café
+      path: Buffer.from([0x63, 0x61, 0x66, 0xc3, 0xa9]).toString(),
+    },
+    {
+      type: 'SymbolicLink',
+      // cafe with a `
+      path: Buffer.from([0x63, 0x61, 0x66, 0x65, 0xcc, 0x81]).toString(),
+      linkpath: 'safe/actually/but/cannot/be/too/careful',
+    },
+    {
+      type: 'File',
+      path: 'bar/baz',
+      size: 1,
+    },
+    'z',
+    '',
+    '',
+  ])
+
+  const check = (path, dirCache, t) => {
+    // symlink blew away all dirCache entries before it
+    path = path.replace(/\\/g, '/')
+    t.strictSame([...dirCache.entries()], [
+      [`${path}`, true],
+      [`${path}/bar`, true],
+    ])
+    t.equal(fs.readFileSync(`${path}/foo/bar`, 'utf8'), 'x')
+    t.equal(fs.readFileSync(`${path}/bar/baz`, 'utf8'), 'z')
+    t.end()
+  }
+
+  t.test('sync', t => {
+    const path = testdir()
+    const dirCache = new Map()
+    new UnpackSync({ cwd: path, dirCache }).end(data)
+    check(path, dirCache, t)
+  })
+
+  t.test('async', t => {
+    const path = testdir()
+    const dirCache = new Map()
+    new Unpack({ cwd: path, dirCache })
+      .on('close', () => check(path, dirCache, t))
+      .end(data)
+  })
+
+  t.end()
+})
diff --git a/test/utils/caller.js b/test/utils/caller.js
new file mode 100644
index 0000000..7f1ecc9
--- /dev/null
+++ b/test/utils/caller.js
@@ -0,0 +1,29 @@
+'use strict';
+
+
+/**
+ * Module wrapper of @substack's `caller.js`
+ * @original: https://github.com/substack/node-resolve/blob/master/lib/caller.js
+ * @blessings: https://twitter.com/eriktoth/statuses/413719312273125377
+ * @see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
+ */
+module.exports = function (depth) {
+    var pst, stack, file, frame;
+
+    pst = Error.prepareStackTrace;
+    Error.prepareStackTrace = function (_, stack) {
+        Error.prepareStackTrace = pst;
+        return stack;
+    };
+
+    stack = (new Error()).stack;
+    depth = !depth || isNaN(depth) ? 1 : (depth > stack.length - 2 ? stack.length - 2 : depth);
+    stack = stack.slice(depth + 1);
+
+    do {
+        frame = stack.shift();
+        file = frame && frame.getFileName();
+    } while (stack.length && file === 'module.js');
+
+    return file;
+};
diff --git a/test/utils/require-inject.js b/test/utils/require-inject.js
new file mode 100644
index 0000000..590b218
--- /dev/null
+++ b/test/utils/require-inject.js
@@ -0,0 +1,97 @@
+'use strict'
+
+if (module === require.main)
+  return require('tap').pass('this is fine')
+
+var Module = require('module')
+var path = require('path')
+var caller = require('./caller')
+
+try {
+  require('readable-stream')
+} catch (_) {
+  // ignore error, just doing the require to work around weirdness in readable-stream
+}
+
+exports = module.exports = function (toLoad, mocks) {
+  return requireInject(toLoad, mocks)
+}
+
+exports.withEmptyCache = function (toLoad, mocks) {
+  return requireInject(toLoad, mocks, true)
+}
+
+exports.installGlobally = installGlobally
+
+exports.installGlobally.andClearCache = function (toLoad, mocks) {
+  var callerFilename = getCallerFilename()
+  Object.keys(require.cache).forEach(function (name) {
+    if (name !== callerFilename) delete require.cache[name]
+  })
+  return installGlobally(toLoad, mocks)
+}
+
+var requireInject = function (toLoad, mocks, withEmptyCache) {
+  mocks = mocks || {}
+
+  // Copy the existing cache
+  var originalCache = {}
+  Object.keys(require.cache).forEach(function (name) {
+    originalCache[name] = require.cache[name]
+  })
+
+  var mocked = withEmptyCache
+    ? installGlobally.andClearCache(toLoad, mocks)
+    : installGlobally(toLoad, mocks)
+
+  // restore the cache, we can't just assign originalCache to require.cache as the require
+  // object is unique to each module, even though require.cache is shared
+  Object.keys(require.cache).forEach(function (name) { delete require.cache[name] })
+  Object.keys(originalCache).forEach(function (name) { require.cache[name] = originalCache[name] })
+
+  return mocked
+}
+
+function resolve (callerFilename, name) {
+  if (/^[.][.]?\//.test(name)) {
+    name = path.resolve(path.dirname(callerFilename), name)
+  }
+  return require.resolve(name)
+}
+
+function getCallerFilename () {
+  var callerFilename
+  for (var ii = 1; ii <= 10; ++ii) {
+    callerFilename = caller(ii)
+    if (callerFilename !== module.filename) return callerFilename
+  }
+  throw new Error("Couldn't find caller that wasn't " + module.filename + ' in most recent 10 stackframes')
+}
+
+function installGlobally (toLoad, mocks) {
+  var callerFilename = getCallerFilename()
+  var parent = require.cache[toLoadPath] || null
+
+  // Inject all of our mocks
+  Object.keys(mocks).forEach(function (name) {
+    var namePath = resolve(callerFilename, name)
+    if (mocks[name] == null) {
+      delete require.cache[namePath]
+    } else {
+      var old = require.cache[namePath]
+      var mod = new Module(namePath, null)
+      mod.filename = namePath
+      mod.exports = mocks[name]
+      mod.loaded = true
+      mod.parent = old ? old.parent : parent
+      require.cache[namePath] = mod
+    }
+  })
+
+  var toLoadPath = resolve(callerFilename, toLoad)
+
+  // remove any unmocked version previously loaded
+  delete require.cache[toLoadPath]
+  // load our new version using our mocks
+  return require.cache[callerFilename].require(toLoadPath)
+}
-- 
2.39.3 

