From 310578d5cbe74ab11c2515298659ea9b5d43f7bf Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Mon, 29 Jan 2024 16:37:42 +0200
Subject: [PATCH 3/5] Seal Security Hotfix for tar 4.4.13

This patch fixes:
  CVE-2021-37713

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/isaacs/node-tar/tree/v4.4.13
---
 lib/strip-absolute-path.js  | 14 +++++++--
 lib/unpack.js               | 21 +++++++++++--
 test/strip-absolute-path.js | 61 ++++++++++++++++++++++++++++++-------
 3 files changed, 81 insertions(+), 15 deletions(-)

diff --git a/lib/strip-absolute-path.js b/lib/strip-absolute-path.js
index 49161dd..819339a 100644
--- a/lib/strip-absolute-path.js
+++ b/lib/strip-absolute-path.js
@@ -2,13 +2,23 @@
 const { isAbsolute, parse } = require('path').win32
 
 // returns [root, stripped]
+// Note that windows will think that //x/y/z/a has a "root" of //x/y, and in
+// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /
+// explicitly if it's the first character.
+// drive-specific relative paths on Windows get their root stripped off even
+// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']
 module.exports = path => {
   let r = ''
-  while (isAbsolute(path)) {
+
+  let parsed = parse(path)
+  while (isAbsolute(path) || parsed.root) {
     // windows will think that //x/y/z has a "root" of //x/y/
-    const root = path.charAt(0) === '/' ? '/' : parse(path).root
+    // but strip the //?/C:/ off of //?/C:/path
+    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'
+    : parsed.root
     path = path.substr(root.length)
     r += root
+    parsed = parse(path)
   }
   return [r, path]
 }
diff --git a/lib/unpack.js b/lib/unpack.js
index 9c65d91..99c0661 100644
--- a/lib/unpack.js
+++ b/lib/unpack.js
@@ -221,7 +221,8 @@ class Unpack extends Parser {
 
     if (!this.preservePaths) {
       const p = normPath(entry.path)
-      if (p.split('/').includes('..')) {
+      const parts = p.split('/')
+      if (parts.includes('..') || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
         this.warn(`path contains '..'`, p)
         return false
       }
@@ -247,6 +248,22 @@ class Unpack extends Parser {
     else
       entry.absolute = normPath(path.resolve(this.cwd, entry.path))
 
+    // if we somehow ended up with a path that escapes the cwd, and we are
+    // not in preservePaths mode, then something is fishy!  This should have
+    // been prevented above, so ignore this for coverage.
+    /* istanbul ignore if - defense in depth */
+    if (!this.preservePaths &&
+      entry.absolute.indexOf(this.cwd + '/') !== 0 &&
+      entry.absolute !== this.cwd) {
+      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
+        entry,
+        path: normPath(entry.path),
+        resolvedPath: entry.absolute,
+        cwd: this.cwd,
+      })
+      return false
+    }
+
     return true
   }
 
@@ -532,7 +549,7 @@ class UnpackSync extends Unpack {
 
   [CHECKFS] (entry) {
     this[PRUNECACHE](entry)
-    
+
     const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)
     if (er)
       return this[ONERROR](er, entry)
diff --git a/test/strip-absolute-path.js b/test/strip-absolute-path.js
index beb057f..745486d 100644
--- a/test/strip-absolute-path.js
+++ b/test/strip-absolute-path.js
@@ -1,14 +1,53 @@
 const t = require('tap')
 const stripAbsolutePath = require('../lib/strip-absolute-path.js')
 
-const cases = {
-  '/': ['/', ''],
-  '////': ['////', ''],
-  'c:///a/b/c': ['c:///', 'a/b/c'],
-  '\\\\foo\\bar\\baz': ['\\\\foo\\bar\\', 'baz'],
-  '//foo//bar//baz': ['//', 'foo//bar//baz'],
-  'c:\\c:\\c:\\c:\\\\d:\\e/f/g': ['c:\\c:\\c:\\c:\\\\d:\\', 'e/f/g'],
-}
-
-for (const [input, [root, stripped]] of Object.entries(cases))
-  t.strictSame(stripAbsolutePath(input), [root, stripped], input)
+const cwd = process.cwd()
+const requireInject = require('./utils/require-inject.js')
+
+t.test('basic', t => {
+  const cases = {
+    '/': ['/', ''],
+    '////': ['////', ''],
+    'c:///a/b/c': ['c:///', 'a/b/c'],
+    '\\\\foo\\bar\\baz': ['\\\\foo\\bar\\', 'baz'],
+    '//foo//bar//baz': ['//', 'foo//bar//baz'],
+    'c:\\c:\\c:\\c:\\\\d:\\e/f/g': ['c:\\c:\\c:\\c:\\\\d:\\', 'e/f/g'],
+  }
+
+  for (const [input, [root, stripped]] of Object.entries(cases))
+    t.strictSame(stripAbsolutePath(input, cwd), [root, stripped], input)
+  t.end()
+})
+
+t.test('drive-local paths', t => {
+  const env = process.env
+  t.teardown(() => process.env = env)
+  const cwd = 'D:\\safety\\land'
+  const realPath = require('path')
+  // be windowsy
+  const path = {
+    ...realPath.win32,
+    win32: realPath.win32,
+    posix: realPath.posix,
+  }
+  const stripAbsolutePath = requireInject('../lib/strip-absolute-path.js', { path })
+  const cases = {
+    '/': ['/', ''],
+    '////': ['////', ''],
+    'c:///a/b/c': ['c:///', 'a/b/c'],
+    '\\\\foo\\bar\\baz': ['\\\\foo\\bar\\', 'baz'],
+    '//foo//bar//baz': ['//', 'foo//bar//baz'],
+    'c:\\c:\\c:\\c:\\\\d:\\e/f/g': ['c:\\c:\\c:\\c:\\\\d:\\', 'e/f/g'],
+    'c:..\\system\\explorer.exe': ['c:', '..\\system\\explorer.exe'],
+    'd:..\\..\\unsafe\\land': ['d:', '..\\..\\unsafe\\land'],
+    'c:foo': ['c:', 'foo'],
+    'D:mark': ['D:', 'mark'],
+    '//?/X:/y/z': ['//?/X:/', 'y/z'],
+    '\\\\?\\X:\\y\\z': ['\\\\?\\X:\\', 'y\\z'],
+  }
+  for (const [input, [root, stripped]] of Object.entries(cases)) {
+    if (!t.strictSame(stripAbsolutePath(input, cwd), [root, stripped], input))
+      break
+  }
+  t.end()
+})
-- 
2.39.3

