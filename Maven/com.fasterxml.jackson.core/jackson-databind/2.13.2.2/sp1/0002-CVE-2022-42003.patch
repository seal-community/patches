From d71dd7052def52dec0565d62ce631553c5ba9889 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Mon, 7 Aug 2023 18:48:50 +0300
Subject: [PATCH 2/2] Seal Security Hotfix for com.fasterxml.jackson.core:jackson-databind 2.13.2.2

This patch fixes:
  CVE-2022-42003

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/FasterXML/jackson-databind/tree/jackson-databind-2.13.2.2
---
 .../databind/DeserializationContext.java      |  17 +++
 .../databind/deser/std/StdDeserializer.java   |  71 +++++++++--
 .../DeepArrayWrappingForDeser3590Test.java    | 113 ++++++++++++++++++
 3 files changed, 189 insertions(+), 12 deletions(-)
 create mode 100644 src/test/java/com/fasterxml/jackson/databind/deser/dos/DeepArrayWrappingForDeser3590Test.java

diff --git a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
index 0cb89aaac..9d4711b4a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
@@ -100,6 +100,7 @@ public abstract class DeserializationContext
      */
     protected final int _featureFlags;
 
+    protected int _primitiveRecursionDepth;
     /**
      * Capabilities of the input format.
      *
@@ -175,6 +176,7 @@ public abstract class DeserializationContext
         }
         _cache = cache;
         _featureFlags = 0;
+        _primitiveRecursionDepth = 0;
         _readCapabilities = null;
         _config = null;
         _injectableValues = null;
@@ -190,6 +192,7 @@ public abstract class DeserializationContext
         
         _config = src._config;
         _featureFlags = src._featureFlags;
+        _primitiveRecursionDepth = 0;
         _readCapabilities = src._readCapabilities;
         _view = src._view;
         _parser = src._parser;
@@ -213,6 +216,7 @@ public abstract class DeserializationContext
 
         _config = config;
         _featureFlags = config.getDeserializationFeatures();
+         _primitiveRecursionDepth = 0;
         _view = config.getActiveView();
         _parser = p;
         _injectableValues = injectableValues;
@@ -234,6 +238,7 @@ public abstract class DeserializationContext
         
         _config = config;
         _featureFlags = config.getDeserializationFeatures();
+         _primitiveRecursionDepth = 0;
         _view = null;
         _parser = null;
         _injectableValues = null;
@@ -249,6 +254,7 @@ public abstract class DeserializationContext
 
         _config = src._config;
         _featureFlags = src._featureFlags;
+         _primitiveRecursionDepth = 0;
         _readCapabilities = src._readCapabilities;
         _view = src._view;
         _injectableValues = null;
@@ -384,6 +390,17 @@ public abstract class DeserializationContext
         return (_featureFlags & feat.getMask()) != 0;
     }
 
+    public final int getPrimitiveRecursionDepth(){
+        return _primitiveRecursionDepth;
+    }
+
+    public final void incPrimitiveRecursionDepth() {
+        _primitiveRecursionDepth += 1;
+    }
+
+    public final void resetPrimitiveRecursionDepth() {
+        _primitiveRecursionDepth = 0;
+    }
     /**
      * Accessor for checking whether input format has specified capability
      * or not.
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
index eef3267fd..c0bdfdc18 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
@@ -40,6 +40,9 @@ public abstract class StdDeserializer<T>
         ValueInstantiator.Gettable // since 2.12
 {
     private static final long serialVersionUID = 1L;
+    // Legitimate or accidental use of more than one nesting level is
+    // plausible, but we have to put the line somewhere.
+    protected static final int maxRecursionDepth = 10;
 
     /**
      * Bitmask that covers {@link DeserializationFeature#USE_BIG_INTEGER_FOR_INTS}
@@ -357,12 +360,8 @@ public abstract class StdDeserializer<T>
         // 23-Mar-2017, tatu: Let's specifically block recursive resolution to avoid
         //   either supporting nested arrays, or to cause infinite looping.
         if (p.hasToken(JsonToken.START_ARRAY)) {
-            String msg = String.format(
-"Cannot deserialize instance of %s out of %s token: nested Arrays not allowed with %s",
-                    ClassUtil.nameOf(_valueClass), JsonToken.START_ARRAY,
-                    "DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS");
             @SuppressWarnings("unchecked")
-            T result = (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p.currentToken(), p, msg);
+            T result = (T) handleNestedArrayForSingle(p, ctxt);
             return result;
         }
         return (T) deserialize(p, ctxt);
@@ -413,8 +412,12 @@ public abstract class StdDeserializer<T>
         case JsonTokenId.ID_START_ARRAY:
             // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (boolean) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final boolean parsed = _parseBooleanPrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -582,8 +585,12 @@ public abstract class StdDeserializer<T>
         case JsonTokenId.ID_START_ARRAY: // unwrapping / from-empty-array coercion?
             // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (byte) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final byte parsed = _parseBytePrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -652,8 +659,12 @@ public abstract class StdDeserializer<T>
         case JsonTokenId.ID_START_ARRAY:
             // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (short) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final short parsed = _parseShortPrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -719,8 +730,12 @@ public abstract class StdDeserializer<T>
             break;
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (int) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final int parsed = _parseIntPrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -848,8 +863,12 @@ public abstract class StdDeserializer<T>
             break;
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (long) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final long parsed = _parseLongPrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -961,8 +980,12 @@ public abstract class StdDeserializer<T>
             break;
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (float) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final float parsed = _parseFloatPrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -1068,8 +1091,12 @@ public abstract class StdDeserializer<T>
             break;
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
+                if (p.nextToken() == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (double) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final double parsed = _parseDoublePrimitive(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -1225,7 +1252,12 @@ public abstract class StdDeserializer<T>
                 default:
                 }
             } else if (unwrap) {
+                if (t == JsonToken.START_ARRAY && ctxt.getPrimitiveRecursionDepth() >= maxRecursionDepth) {
+                    return (java.util.Date) handleNestedArrayForSingle(p, ctxt);
+                }
+                ctxt.incPrimitiveRecursionDepth();
                 final Date parsed = _parseDate(p, ctxt);
+                ctxt.resetPrimitiveRecursionDepth();
                 _verifyEndArrayForSingle(p, ctxt);
                 return parsed;
             }
@@ -2005,6 +2037,21 @@ handledType().getName());
         //     but for now just fall through
     }
 
+    /**
+     * Helper method called when detecting a deep(er) nesting of Arrays when trying
+     * to unwrap value for {@code DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS}.
+     *
+     * @since 2.13.4.1
+     */
+    protected Object handleNestedArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException
+    {
+        String msg = String.format(
+"Cannot deserialize instance of %s out of %s token: nested Arrays not allowed with %s",
+                ClassUtil.nameOf(_valueClass), JsonToken.START_ARRAY,
+                "DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS");
+        return ctxt.handleUnexpectedToken(getValueType(ctxt), p.currentToken(), p, msg);
+    }
+
     protected void _verifyEndArrayForSingle(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         JsonToken t = p.nextToken();
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/dos/DeepArrayWrappingForDeser3590Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/dos/DeepArrayWrappingForDeser3590Test.java
new file mode 100644
index 000000000..70f086efb
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/dos/DeepArrayWrappingForDeser3590Test.java
@@ -0,0 +1,113 @@
+package com.fasterxml.jackson.databind.deser.dos;
+
+import java.util.Date;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
+
+public class DeepArrayWrappingForDeser3590Test extends BaseMapTest
+{
+    // 05-Sep-2022, tatu: Before fix, failed with 5000
+    private final static int TOO_DEEP_NESTING = 12;
+
+    private final ObjectMapper MAPPER = jsonMapperBuilder()
+            .enable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
+            .build();
+
+    private final static String TOO_DEEP_DOC = _nestedDoc(TOO_DEEP_NESTING, "[ ", "] ", "123");
+
+    public void testArrayWrappingForBoolean() throws Exception
+    {
+        _testArrayWrappingFor(Boolean.class);
+        _testArrayWrappingFor(Boolean.TYPE);
+    }
+
+    public void testArrayWrappingForByte() throws Exception
+    {
+        _testArrayWrappingFor(Byte.class);
+        _testArrayWrappingFor(Byte.TYPE);
+    }
+
+    public void testArrayWrappingForShort() throws Exception
+    {
+        _testArrayWrappingFor(Short.class);
+        _testArrayWrappingFor(Short.TYPE);
+    }
+
+    public void testArrayWrappingForInt() throws Exception
+    {
+        _testArrayWrappingFor(Integer.class);
+        _testArrayWrappingFor(Integer.TYPE);
+    }
+
+    public void testArrayWrappingForLong() throws Exception
+    {
+        _testArrayWrappingFor(Long.class);
+        _testArrayWrappingFor(Long.TYPE);
+    }
+
+    public void testArrayWrappingForFloat() throws Exception
+    {
+        _testArrayWrappingFor(Float.class);
+        _testArrayWrappingFor(Float.TYPE);
+    }
+
+    public void testArrayWrappingForDouble() throws Exception
+    {
+        _testArrayWrappingFor(Double.class);
+        _testArrayWrappingFor(Double.TYPE);
+    }
+
+    public void testArrayWrappingForDate() throws Exception
+    {
+        _testArrayWrappingFor(Date.class);
+    }
+
+    public void testArrayWrappingForPoint() throws Exception
+    {
+        try {
+            MAPPER.readValue("[[[[[[{\"x\":[[[[[[[5]]]]]]],\"y\":[[[[[[[[[[[[[3]]]]]]]]]]]]]}]]]]]]", Point.class);
+            fail("Should not pass");
+        } catch (MismatchedInputException e) {
+            verifyException(e, "Cannot deserialize");
+            verifyException(e, "nested Arrays not allowed");
+        }
+    }
+    public void testArrayWrappingForPointPass() throws Exception
+    {
+        try {
+            MAPPER.readValue("[[[[[[{\"x\":[[[[[[[5]]]]]]],\"y\":[[[[[[[[[3]]]]]]]]]}]]]]]]", Point.class);
+        } catch (MismatchedInputException e) {
+            fail("Should not throw exception");
+        }
+    }
+    private void _testArrayWrappingFor(Class<?> cls) throws Exception
+    {
+        try {
+            MAPPER.readValue(TOO_DEEP_DOC, cls);
+            fail("Should not pass");
+        } catch (MismatchedInputException e) {
+            verifyException(e, "Cannot deserialize");
+            verifyException(e, "nested Arrays not allowed");
+        }
+    }
+
+    private static String _nestedDoc(int nesting, String open, String close, String content) {
+        StringBuilder sb = new StringBuilder(nesting * (open.length() + close.length()));
+        for (int i = 0; i < nesting; ++i) {
+            sb.append(open);
+            if ((i & 31) == 0) {
+                sb.append("\n");
+            }
+        }
+        sb.append("\n").append(content).append("\n");
+        for (int i = 0; i < nesting; ++i) {
+            sb.append(close);
+            if ((i & 31) == 0) {
+                sb.append("\n");
+            }
+        }
+        return sb.toString();
+    }
+
+}
-- 

