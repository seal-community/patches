From 3dabe41e30f03f75c99c3658ff580bd3a162a5b7 Mon Sep 17 00:00:00 2001
From: Seal <info@seal.security>
Date: Thu, 10 Aug 2023 11:43:29 +0300
Subject: [PATCH 1/1] Seal Security Hotfix for net.minidev:json-smart 2.4.8

This patch fixes:
  CVE-2023-1370

For more information see:
  1. https://seal.security
  2. https://github.com/seal-community
  3. https://github.com/netplex/json-smart-v2/tree/2.4.8
---
 .../main/java/net/minidev/json/JSONArray.java |  7 +++
 .../java/net/minidev/json/JSONObject.java     |  4 ++
 .../minidev/json/parser/JSONParserBase.java   | 24 +++++++--
 .../json/parser/JSONParserByteArray.java      |  2 +-
 .../minidev/json/parser/ParseException.java   |  7 +++
 .../net/minidev/json/test/TestOverflow.java   | 50 +++++++++++++++++++
 6 files changed, 90 insertions(+), 4 deletions(-)
 create mode 100644 json-smart/src/test/java/net/minidev/json/test/TestOverflow.java

diff --git a/json-smart/src/main/java/net/minidev/json/JSONArray.java b/json-smart/src/main/java/net/minidev/json/JSONArray.java
index 1a1c257..981533a 100644
--- a/json-smart/src/main/java/net/minidev/json/JSONArray.java
+++ b/json-smart/src/main/java/net/minidev/json/JSONArray.java
@@ -30,6 +30,13 @@ import net.minidev.json.reader.JsonWriter;
 public class JSONArray extends ArrayList<Object> implements List<Object>, JSONAwareEx, JSONStreamAwareEx {
 	private static final long serialVersionUID = 9106884089231309568L;
 
+	public JSONArray() {
+	}
+
+	public JSONArray(int initialCapacity) {
+		super(initialCapacity);
+	}
+
 	public static String toJSONString(List<? extends Object> list) {
 		return toJSONString(list, JSONValue.COMPRESSION);
 	}
diff --git a/json-smart/src/main/java/net/minidev/json/JSONObject.java b/json-smart/src/main/java/net/minidev/json/JSONObject.java
index ea585e0..0c29589 100644
--- a/json-smart/src/main/java/net/minidev/json/JSONObject.java
+++ b/json-smart/src/main/java/net/minidev/json/JSONObject.java
@@ -35,6 +35,10 @@ public class JSONObject extends HashMap<String, Object> implements JSONAwareEx,
 		super();
 	}
 
+	public JSONObject(int initialCapacity) {
+		super(initialCapacity);
+	}
+
 	/**
 	 * Escape quotes, \, /, \r, \n, \b, \f, \t and other control characters
 	 * (U+0000 through U+001F). It's the same as JSONValue.escape() only for
diff --git a/json-smart/src/main/java/net/minidev/json/parser/JSONParserBase.java b/json-smart/src/main/java/net/minidev/json/parser/JSONParserBase.java
index 5a0e67f..2c1755b 100644
--- a/json-smart/src/main/java/net/minidev/json/parser/JSONParserBase.java
+++ b/json-smart/src/main/java/net/minidev/json/parser/JSONParserBase.java
@@ -20,6 +20,7 @@ import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_EOF;
 import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_LEADING_0;
 import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_TOKEN;
 import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_UNICODE;
+import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_JSON_DEPTH;
 
 import java.io.IOException;
 import java.math.BigDecimal;
@@ -39,6 +40,12 @@ import net.minidev.json.writer.JsonReaderI;
  */
 abstract class JSONParserBase {
 	protected char c;
+	/**
+	 * hard coded maximal depth for JSON parsing
+	 */
+	public final static int MAX_DEPTH = 400;
+	protected int depth = 0;
+
 	JsonReader base;
 	public final static byte EOI = 0x1A;
 	protected static final char MAX_STOP = 126; // '}' -> 125
@@ -94,7 +101,9 @@ abstract class JSONParserBase {
 		this.acceptLeadinZero = (permissiveMode & JSONParser.ACCEPT_LEADING_ZERO) > 0;
 		this.acceptUselessComma = (permissiveMode & JSONParser.ACCEPT_USELESS_COMMA) > 0;
 		this.useHiPrecisionFloat = (permissiveMode & JSONParser.USE_HI_PRECISION_FLOAT) > 0;
-		this.checkTaillingData = (permissiveMode & (JSONParser.ACCEPT_TAILLING_DATA | JSONParser.ACCEPT_TAILLING_SPACE)) != (JSONParser.ACCEPT_TAILLING_DATA | JSONParser.ACCEPT_TAILLING_SPACE);
+		this.checkTaillingData = (permissiveMode & (JSONParser.ACCEPT_TAILLING_DATA
+				| JSONParser.ACCEPT_TAILLING_SPACE)) != (JSONParser.ACCEPT_TAILLING_DATA
+						| JSONParser.ACCEPT_TAILLING_SPACE);
 		this.checkTaillingSpace = (permissiveMode & JSONParser.ACCEPT_TAILLING_SPACE) == 0;
 		this.reject127 = (permissiveMode & JSONParser.REJECT_127_CHAR) > 0;
 		this.unrestictBigDigit = (permissiveMode & JSONParser.BIG_DIGIT_UNRESTRICTED) > 0;
@@ -284,14 +293,17 @@ abstract class JSONParserBase {
 	abstract protected void read() throws IOException;
 
 	protected <T> T readArray(JsonReaderI<T> mapper) throws ParseException, IOException {
-		Object current = mapper.createArray();
 		if (c != '[')
 			throw new RuntimeException("Internal Error");
+		if (++this.depth > MAX_DEPTH) {
+			throw new ParseException(pos, ERROR_UNEXPECTED_JSON_DEPTH, c);
+		}
+		Object current = mapper.createArray();
 		read();
 		boolean needData = false;
 		// special case needData is false and can close is true
 		if (c == ',' && !acceptUselessComma)
-			throw new ParseException(pos, ERROR_UNEXPECTED_CHAR, (char) c);			
+			throw new ParseException(pos, ERROR_UNEXPECTED_CHAR, (char) c);
 		for (;;) {
 			switch (c) {
 			case ' ':
@@ -303,6 +315,7 @@ abstract class JSONParserBase {
 			case ']':
 				if (needData && !acceptUselessComma)
 					throw new ParseException(pos, ERROR_UNEXPECTED_CHAR, (char) c);
+				this.depth--;
 				read(); /* unstack */
 				//
 				return mapper.convert(current);
@@ -539,6 +552,9 @@ abstract class JSONParserBase {
 		//
 		if (c != '{')
 			throw new RuntimeException("Internal Error");
+		if (++this.depth > MAX_DEPTH) {
+			throw new ParseException(pos, ERROR_UNEXPECTED_JSON_DEPTH, c);
+		}
 		Object current = mapper.createObject();
 		boolean needData = false;
 		boolean acceptData = true;
@@ -558,6 +574,7 @@ abstract class JSONParserBase {
 			case '}':
 				if (needData && !acceptUselessComma)
 					throw new ParseException(pos, ERROR_UNEXPECTED_CHAR, (char) c);
+				this.depth--;
 				read(); /* unstack */
 				//
 				return mapper.convert(current);
@@ -602,6 +619,7 @@ abstract class JSONParserBase {
 				// should loop skipping read step
 				skipSpace();
 				if (c == '}') {
+					this.depth--;
 					read(); /* unstack */
 					//
 					return mapper.convert(current);
diff --git a/json-smart/src/main/java/net/minidev/json/parser/JSONParserByteArray.java b/json-smart/src/main/java/net/minidev/json/parser/JSONParserByteArray.java
index 348bce9..f402631 100644
--- a/json-smart/src/main/java/net/minidev/json/parser/JSONParserByteArray.java
+++ b/json-smart/src/main/java/net/minidev/json/parser/JSONParserByteArray.java
@@ -19,7 +19,7 @@ import static net.minidev.json.parser.ParseException.ERROR_UNEXPECTED_EOF;
 import net.minidev.json.JSONValue;
 import net.minidev.json.writer.JsonReaderI;
 
-import java.nio.charset.Charset;
+
 import java.nio.charset.StandardCharsets;
 
 /**
diff --git a/json-smart/src/main/java/net/minidev/json/parser/ParseException.java b/json-smart/src/main/java/net/minidev/json/parser/ParseException.java
index e9332d9..ced48af 100644
--- a/json-smart/src/main/java/net/minidev/json/parser/ParseException.java
+++ b/json-smart/src/main/java/net/minidev/json/parser/ParseException.java
@@ -30,6 +30,7 @@ public class ParseException extends Exception {
 	public static final int ERROR_UNEXPECTED_UNICODE = 4;
 	public static final int ERROR_UNEXPECTED_DUPLICATE_KEY = 5;
 	public static final int ERROR_UNEXPECTED_LEADING_0 = 6;
+	public static final int ERROR_UNEXPECTED_JSON_DEPTH = 7;
 
 	private int errorType;
 	private Object unexpectedObject;
@@ -114,6 +115,12 @@ public class ParseException extends Exception {
 			sb.append(" at position ");
 			sb.append(position);
 			sb.append(".");
+		} else if (errorType == ERROR_UNEXPECTED_JSON_DEPTH) {
+			sb.append("Malicious payload, having non natural depths, parsing stoped on ");
+			sb.append(unexpectedObject);
+			sb.append(" at position ");
+			sb.append(position);
+			sb.append(".");
 		} else {
 			sb.append("Unkown error at position ");
 			sb.append(position);
diff --git a/json-smart/src/test/java/net/minidev/json/test/TestOverflow.java b/json-smart/src/test/java/net/minidev/json/test/TestOverflow.java
new file mode 100644
index 0000000..07912f2
--- /dev/null
+++ b/json-smart/src/test/java/net/minidev/json/test/TestOverflow.java
@@ -0,0 +1,50 @@
+package net.minidev.json.test;
+
+import net.minidev.json.JSONArray;
+import net.minidev.json.JSONValue;
+import net.minidev.json.parser.ParseException;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import org.junit.jupiter.api.Test;
+
+public class TestOverflow {
+	@Test
+	public void stressTest() throws Exception {
+		int size = 10000;
+		StringBuilder sb = new StringBuilder(10 + size*4);
+		for (int i=0; i < size; i++) {
+			sb.append("{a:");
+		}
+		sb.append("true");
+		for (int i=0; i < size; i++) {
+			sb.append("}");
+		}
+		String s = sb.toString();
+		try {
+			JSONValue.parseWithException(s);
+		} catch (ParseException e) {
+			assertEquals(e.getErrorType(), ParseException.ERROR_UNEXPECTED_JSON_DEPTH);
+			return;
+		}
+		assertTrue(false);
+	}
+
+	@Test
+	public void shouldNotFailParsingArraysWith400Elements() throws Exception {
+		int size = 400;
+		StringBuilder sb = new StringBuilder();
+		sb.append("[");
+		for (int i=0; i < size; i++) {
+			sb.append("{a:true}");
+			if(i+1 < size) {
+				sb.append(",");
+			}
+		}
+		sb.append("]");
+		String s = sb.toString();
+		JSONArray array = (JSONArray) JSONValue.parseWithException(s);
+		assertEquals(array.size(), size);
+	}
+}
-- 

